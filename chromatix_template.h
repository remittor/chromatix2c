/*========================================================================
                          C H R O M A T I X

   DESCRIPTION
   Auto-Generated by Chromatix tool defining camera tunable parameters.

Copyright (c) 2012-2013 Qualcomm Technologies, Inc. All Rights Reserved.
Qualcomm Technologies Proprietary and Confidential.
Export of this technology or software is regulated by the U.S. Government.
Diversion contrary to U.S. law prohibited.
==========================================================================*/

/* Chromatix common DMSS header file version number */
`xu2`,
`xu1+1`, // Not compressed
`xu2+2`, // Revision
/* VFE Blocks */
{
   /* Black-Level Subtraction */
   {

/*********************************************************************/
// Feature name :
// Use gain or lux_index to control black level subtraction.
// Range: 0 or 1.
// 0 means to use lux_index to control.
// 1 means to use gain to control.
/*********************************************************************/

      `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */

/*********************************************************************/
// Feature name :
// Trigger point for black level subtraction.
// gain start :
// When gain >= gain_start, lowlight black level is interpolated with normal black level.
// Range: min_gain to max_gain. Gain means digital and analog combined gain.
// Effect: Increasing this value will use lowlight black level under lower light condition.
//
// gain end:
// When gain >= gain_end, 100% lowlight black level is used.
// Range: min_gain to max_gain. Gain means digital and analog combined gain.
// Constraint: gain_end > gain_start.
// Effect: Increasing this value will use 100% lowlight black level under lower light condition.
//
// lux_index_start:
// When lux_index >= lux_index_start, lowlight black level is interpolated with normal black level.
// Range: For linear AFR case: 0 to max_index from exposure table.
//		  For non-linear AFR case : 0 to max_index*numberof_FPS_supported.
// Effect: Increasing this value will use lowlight black level under lower light condition.
//
// lux_index_end:
// When lux_index >= lux_index_end, 100% lowlight black level is used.
// Range: For linear AFR case: 0 to max_index from exposure table.
//		  For non-linear AFR case : 0 to max_index*numberof_FPS_supported.
// Constraint: lux_index_end > lux_index_start.
// Effect: Increasing this value will use 100% lowlight black level under lower light condition.
//
/*********************************************************************/

      /* Low-Light Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },

/*********************************************************************/
// Feature name :
// Amount of black level increase under lowlight.
// Range: 0 to "black level offset"(next entry in chromatix header)
// Constraint: Smaller than or equal to "black level offset".
// Effect: Larger value will increase signal level but has less contrast.
/*********************************************************************/

      `xu2`, /* Max Black Increase */

/*********************************************************************/
// Feature name :
// 4 channel Black level offsets under normal and bright light.
// This set parameters is used in QSC6270(6240), QSC6295, QSD8x50.
// Range: 0 to 1023 for MSM7x25, MSM7x27 and QSD8x50; 0 to 256 for QSC6270(6240), QSC6295.
// Effect: Usually we should use sensor recommended value. Smaller value will
//		   reduce contrast and has "foggy" effect.
/*********************************************************************/

      /* Four Channel Normal Light Black-Level */
      {`xu2a4+2`},
   },
   /* Channel Balance Gains */
   {`xf4a4`},

/******************************************************************************/
// Feature name : ABF2.
// Applicale chipset: QSD8x60, MSM7x30 and later.
// Applicable operation mode:  For VF and snapshot.
//
// Desription of variables in chromatix_adaptive_bayer_filter_data_type2
// structure.
//
// Variable names: threshold_red[3], threshold_green[3],threshold_blue[3].
// The three threshold values for each of
// the red, green, and blue channels define boundaries for smoothing,
// no-processing, and sharpening regions of ABF filter.
// Default values (for 12-bit data):
//   low-light : threshold_red[0]=24*16; threshold_red[1]=24*16; threshold_red[2]=25*16;
//   med-light : threshold_red[0]=21*16; threshold_red[1]=21*16; threshold_red[2]=22*16;
//   high-light: threshold_red[0]=18*16; threshold_red[1]=18*16; threshold_red[2]=19*16;
//   Default values of threshold_green[0-2] and threshold_blue[0-2] are same as
//   threshold_red[0-2] for different exposure levels
// Data range: 0 to 255*16 (for 12-bit data).
// Constraints: threshold_red[0] <= threshold_red[1] < threshold_red[2].
// Effect: Larger value for threshold_red[0] will result in increased smoothing area;
// larger value for threshold_red[1] will result in reduced sharpening area.
//
// Variable names: scale_factor_red[2], scale_factor_green[2],scale_factor_blue[2].
// Control extent of smoothing and sharpening in
// smoothing and sharpening regions of the new ABF filter.
// Default values:
//   low-light  : scale_factor_red[0]=0.80; scale_factor_red[1]=0.04;
//   med-light  : scale_factor_red[0]=0.68; scale_factor_red[1]=0.04;
//   high-light : scale_factor_red[0]=0.50; scale_factor_red[1]=0.04;
//   Default values of scale_factor_green[0-1] and scale_factor blue[0-1] are
//   same as scale_factor_red[0-1] for different exposure levels
// Data range: 0 to 1.
// Constraints: 0 < scale_factor_red[0-1] <= 1; similar contrasints applicable
// to green- and blue-channel scaling factors.
// Effect: Larger value for scale_factor_red\green\blue[0] increases smoothing in
// smoothing region of ABF filter; larger value for scale_factor_red\green\blue[1]
// increases sharpening in sharpening region of ABF filter.
//
// variable name: a[2]
// Spatial component of ABF filter; controls
// influence of neighboring pixels on output pixel value
// default values:
//   low-light  : a[0] = a[1] = 1;
//   med-light  : a[0] = a[1] = 1;
//   high-light : a[0] = a[1] = 1;
// Data range: 0 to 1.
// Constraints: 0 <= a[0-1] <= 1;
// Effect: When a[0] = a[1] = 0, ABF is essentially turned off; When a[0] = a[1] = 1,
// we see maximum smoothing/sharpening effects of applying the ABF filter.
//
// Variable name: table_pos[16].
// Lookup table values determine
// amount of smoothing at different levels of local gradient magnitude.
// Default values:
// table_pos[16] = {1.0000, 0.9764, 0.9214, 0.8346, 0.7244, 0.6063, 0.4882,
//     0.3780, 0.2756, 0.1969, 0.1339, 0.0866, 0.0551, 0.0315, 0.0236, 0.0079};
// Data range: 0 to 1.
// Constraints: 0 <= table_pos[0-15] <= 1;
// Effect: Larger values for table_pos[0-15] entries represent increased amount of
// smoothing. We do not recommend changing these values.
//
// Variable name: table_neg[8].
// Lookup table values determine
// amount of sharpening at different values of local gradient magnitude.
// Default values:
// table_neg[8] = {-1.000, -1.000, -1.000, -1.000, -1.000, -1.000, -1.000, -1.000}.
// Data range: -1.000 to 0.000
// Constraints: -1.0 <= table_neg[0-7] <= 0.0;
// Effect: Larger values for table_neg[0-7] represent increased amount of
// sharpening. We do not recommend changing these values.
/******************************************************************************/

   /* Adaptive Bayer Filter 2 */
   {
      `xu1+1`, /* Control Method - 1 = Gain, 0 = Lux Index */
      `xu2`, /* Enable Lux Index */

/******************************************************************************/
// Feature name : ABF2 Low Light Trigger Points
/******************************************************************************/

      /* ABF2 Low Light Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },

/******************************************************************************/
// Feature name : ABF2 Bright Light Trigger Points
/******************************************************************************/

      /* ABF2 Bright Light Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },

/******************************************************************************/
// Feature name : ABF2 Low Light parameters
/******************************************************************************/

      /* ABF2 Low Light */
      {
         /* Red channel parameters */
         {`xu2a3+2`}, /* 12-bit pixels */
         {`xf4a2`},

         /* Green channel parameters */
         {`xu2a3+2`}, /* 12-bit pixels */
         {`xf4a2`},
         {`xf4a2`},

         /* Blue channel parameters */
         {`xu2a3+2`}, /* 12-bit pixels */
         {`xf4a2`},

         /* Positive table */
         {
            `xf4a4`,
            `xf4a4`,
            `xf4a4`,
            `xf4a4`
         },
         /* Negative table */
         {
            `xf4a4`,
            `xf4a4`
         },
      },
      /* ABF2 Normal Light */
      {
         /* Red channel parameters */
         {`xu2a3+2`}, /* 12-bit pixels */
         {`xf4a2`},

         /* Green channel parameters */
         {`xu2a3+2`}, /* 12-bit pixels */
         {`xf4a2`},
         {`xf4a2`},

         /* Blue channel parameters */
         {`xu2a3+2`}, /* 12-bit pixels */
         {`xf4a2`},

         /* Positive table */
         {
            `xf4a4`,
            `xf4a4`,
            `xf4a4`,
            `xf4a4`
         },
         /* Negative table */
         {
            `xf4a4`,
            `xf4a4`
         },
      },
      /* ABF2 Bright Light */
      {
         /* Red channel parameters */
         {`xu2a3+2`}, /* 12-bit pixels */
         {`xf4a2`},

         /* Green channel parameters */
         {`xu2a3+2`}, /* 12-bit pixels */
         {`xf4a2`},
         {`xf4a2`},

         /* Blue channel parameters */
         {`xu2a3+2`}, /* 12-bit pixels */
         {`xf4a2`},

         /* Positive table */
         {
            `xf4a4`,
            `xf4a4`,
            `xf4a4`,
            `xf4a4`
         },
         /* Negative table */
         {
            `xf4a4`,
            `xf4a4`
         },
      },
   },
   /* Bad Pixel Correction */
   {

/*********************************************************************/
// Feature name : bad pixel correction parameters
// Fmin and Fmax are used for bad pixel correction (BPC).
// Range: 1 to 127.
// Constraint: Fmax > Fmin.
// Effect: Smaller Fmin and higher Fmax will have least amount of correction.
//        Setting Fmax=Fmin will have the max amount of correction.
/*********************************************************************/


/*********************************************************************/
// Feature name :
// The following BPC parameters are used for QSD8x50, QSC6270(6240), QSC6295,MSM7x25, MSM7x27.
//
/*********************************************************************/


/*********************************************************************/
// Feature name :
// Use gain or lux_index to control BPC.
// Range: 0 or 1.
// 0 means to use lux_index to control.
// 1 means to use gain to control.
/*********************************************************************/

      `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */

/*********************************************************************/
// Feature name :
// Trigger point for lowlight BPC.
// gain start :
// When gain >= gain_start, lowlight BPC is interpolated with normal BPC.
// Range: min_gain to max_gain. Gain means digital and analog combined gain.
// Effect: Increasing this value will use lowlight BPC under lower light condition.
//
// gain end:
// When gain >= gain_end, 100% lowlight BPC is used.
// Range: min_gain to max_gain. Gain means digital and analog combined gain.
// Constraint: gain_end > gain_start.
// Effect: Increasing this value will use 100% lowlight BPC under lower light condition.
//
// lux_index_start:
// When lux_index >= lux_index_start, lowlight BPC is interpolated with normal BPC.
// Range: For linear AFR case: 0 to max_index from exposure table.
//		  For non-linear AFR case : 0 to max_index*numberof_FPS_supported.
// Effect: Increasing this value will use lowlight BPC under lower light condition.
//
// lux_index_end:
// When lux_index >= lux_index_end, 100% lowlight BPC is used.
// Range: for linear AFR case: 0 to max_index from exposure table.
//		  For non-linear AFR case : 0 to max_index*numberof_FPS_supported.
// Constraint: lux_index_end > lux_index_start.
// Effect: Increasing this value will use 100% lowlight BPC under lower light condition.
//
/*********************************************************************/

      /* Low-Light Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },
      `xu1`, /* Fmin */
      `xu1`, /* Fmax */
      `xu1`, /* Lowlight Fmin */
      `xu1`, /* Lowlight Fmax */

/******************************************************************************/
// Feature name : bad pixel correction.
// Applicable chipset:  MSM7x30, QSD8x60 and later.
// Applicable operation mode: Viewfinder and snapshot.
//
// Variable name: bpc_offset_r_hi.
// Red channel pixel difference higher offset value.
// Default value: 0.
// Data range: 0 to 1023.
// Constraints: bpc_offset_r_hi >= bpc_offset_r_lo.
// Effect: Higher value results in less DPC to be corrected.
//
// Variable name: bpc_offset_r_lo.
// Red channel pixel difference lower offset value.
// Default value: 0.
// Data range: 0 to 1023.
// Constraints: bpc_offset_r_hi >= bpc_offset_r_lo.
// Effect: Higher value results in less DPC to be corrected.
//
// Variable name: bpc_offset_gr_hi.
// Green (next to red) channel pixel difference higher offset value
// Default Value: 0.
// Data Range: 0 to 1023.
// Constraints: bpc_offset_gr_hi >= bpc_offset_gr_lo.
// Effect: Higher value results in less DPC to be corrected.
//
// Variable name: bpc_offset_gr_lo.
// Green (next to red) channel pixel difference lower offset value
// Default Value: 0.
// Data Range: 0 to 1023.
// Constraints: bpc_offset_gr_hi >= bpc_offset_gr_lo.
// Effect: Higher value results in less DPC to be corrected.
//
// Variable name: bpc_offset_gb_hi.
// Green (next to blue) channel pixel difference higher offset value.
// Default value: 0.
// Data range: 0 to 1023.
// Constraints: bpc_offset_gb_hi >= bpc_offset_gb_lo.
// Effect: Higher value results in less DPC to be corrected.
//
// Variable name: bpc_offset_gb_lo.
// Green (next to blue) channel pixel difference lower offset value.
// Default value: 0.
// Data range: 0 to 1023.
// Constraints: bpc_offset_gb_hi >= bpc_offset_gb_lo.
// Effect: Higher value results in less DPC to be corrected.
//
// Variable name: bpc_offset_b_hi.
// Blue channel pixel difference higher offset value.
// Default value: 0.
// Data range: 0 to 1023.
// Constraints: bpc_offset_b_hi >= bpc_offset_b_lo.
// Effect: Higher value results in less DPC to be corrected.
//
// variable name: bpc_offset_b_lo.
// Description:  Blue channel pixel difference lower offset value.
// Default value: 0.
// Data range: 0 to 1023.
// Constraints: bpc_offset_b_hi >= bpc_offset_b_lo.
// Effect: Higher value results in less DPC to be corrected.
/******************************************************************************/

      /* Offsets */
      {
         /* Normal Light */
         {
            `xu2`, /* R Hi */
            `xu2`, /* R Lo */
            `xu2`, /* Gr Hi */
            `xu2`, /* Gr Lo */
            `xu2`, /* Gb Hi */
            `xu2`, /* Gb Lo */
            `xu2`, /* B Hi */
            `xu2`, /* B Lo */
         },
         /* Low Light */
         {
            `xu2`, /* R Hi */
            `xu2`, /* R Lo */
            `xu2`, /* Gr Hi */
            `xu2`, /* Gr Lo */
            `xu2`, /* Gb Hi */
            `xu2`, /* Gb Lo */
            `xu2`, /* B Hi */
            `xu2`, /* B Lo */
         },
      },

/******************************************************************************/
// Feature name : bad cluster correction (BCC)
/******************************************************************************/

      `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */

/******************************************************************************/
// Feature name : BCC lowlight trigger points
/******************************************************************************/

      /* Low-Light Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },
      `xu1`, /* Fmin */
      `xu1`, /* Fmax */
      `xu1`, /* Lowlight Fmin */
      `xu1`, /* Lowlight Fmax */

/******************************************************************************/
// Feature name : BCC offset parameters
// Applicable chipset:  8960 and later.
// Applicable operation mode: Viewfinder and snapshot.
//
// Variable name: bcc_offset_r_hi.
// Red channel pixel difference higher offset value.
// Default value: 0.
// Data range: 0 to 1023.
// Constraints: bcc_offset_r_hi >= bcc_offset_r_lo.
// Effect: Higher value results in less BCC to be corrected
//
// Variable name: bcc_offset_r_lo.
// Red channel pixel difference lower offset value.
// Default value: 0.
// Data range: 0 to 1023.
// Constraints: bcc_offset_r_hi >= bcc_offset_r_lo.
// Effect: Higher value results in less DCC to be corrected.
//
// Variable name: bcc_offset_gr_hi.
// Green(next to red) channel pixel difference higher offset value.
// Default value: 0.
// Data range: 0 to 1023.
// Constraints: bcc_offset_gr_hi >= bcc_offset_gr_lo.
// Effect: Higher value results in less DCC to be corrected.
//
// Variable name: bcc_offset_gr_lo.
// Green(next to red) channel pixel difference lower offset value.
// Default value: 0.
// Data range: 0 to 1023.
// Constraints: bcc_offset_gr_hi >= bcc_offset_gr_lo.
// Effect: Higher value results in less DCC to be corrected.
//
// Variable name: bcc_offset_gb_hi.
// Green (next to blue) channel pixel difference higher offset value.
// Default value: 0.
// Data range: 0 to 1023.
// Constraints: bcc_offset_gb_hi >= bcc_offset_gb_lo.
// Effect: Higher value results in less DCC to be corrected.
//
// Variable name: bcc_offset_gb_lo.
// Green (next to blue) channel pixel difference lower offset value.
// Default value: 0.
// Data range: 0 to 1023.
// Constraints: bcc_offset_gb_hi >= bcc_offset_gb_lo.
// Effect: Higher value results in less DCC to be corrected.
//
// Variable name: bcc_offset_b_hi.
// Blue channel pixel difference higher offset value.
// Default value: 0.
// Data range: 0 to 1023.
// Constraints: bcc_offset_b_hi >= bcc_offset_b_lo.
// Effect: Higher value results in less DCC to be corrected.
//
// Variable name: bcc_offset_b_lo.
// Blue channel pixel difference lower offset value.
// Default value: 0.
// Data range: 0 to 1023.
// Constraints: bcc_offset_b_hi >= bcc_offset_b_lo.
// Effect: Higher value results in less DCC to be corrected.
/******************************************************************************/

      /* Offsets */
      {
         /* Normal Light */
         {
            `xu2`, /* R Hi */
            `xu2`, /* R Lo */
            `xu2`, /* Gr Hi */
            `xu2`, /* Gr Lo */
            `xu2`, /* Gb Hi */
            `xu2`, /* Gb Lo */
            `xu2`, /* B Hi */
            `xu2`, /* B Lo */
         },
         /* Low Light */
         {
            `xu2`, /* R Hi */
            `xu2`, /* R Lo */
            `xu2`, /* Gr Hi */
            `xu2`, /* Gr Lo */
            `xu2`, /* Gb Hi */
            `xu2`, /* Gb Lo */
            `xu2`, /* B Hi */
            `xu2`, /* B Lo */
         },
      },
   },
   /* Demosaic3 */
   {
      `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */

/******************************************************************************/
// Feature name : Demosaic3 lowlight trigger points
/******************************************************************************/

      /* Low-Light Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },

/******************************************************************************/
// Feature name: Demosaic3.
// Applicale chipset(s): 8960, 8x55A and later chipsets.
// Applicable operation mode:
//     Viewfinder, snapshot processing, and video modes.
// 3A mode: N/A.
//
// Variable name: wk[18] // HW: 10uQ10
// Discrete adaboost parameters required for local window classification.
// Default value: {0.1338, 0.0889, 0.0889, 0.9990, 0.9004, 0.0908, 0.1904,
// 0.0967, 0.0625, 0.3115, 0.1924, 0.0859, 0.0820, 0.1064,  0.1475, 0.0957,
// 0.0645, 0.0742}.
// Range for each element in 18-D array: [0,1.0].
// The classification parameters are optimized in an offline
// training process. Once the parameters are optimized, they remain fixed.
//
// Variable name: bk[18]  // HW: 1uQ0
// Discrete adaboost parameters required for local window classification.
// Default: {1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1}.
// Range for each element in 18-D array: {0,1}.
// The classification parameters are optimized in an offline
// training process. Once the parameters are optimized, they remain fixed.
//
// Variable name: lk[18]  // HW: 4uQ0
// Discrete adaboost parameters required for local window classification.
// Default value: {0, 0, 1, 2, 2, 3, 9, 9, 9, 4, 4, 5, 6, 7, 8, 8, 10, 10}.
// Range for each element in 18-D array is {0, 1, ..., 12}.
// The classification parameters are optimized in an offline
// training process. Once the parameters are optimized, they remain fixed.
//
// Variable name: Tk[18]  // HW: 10sQ0
// Discrete adaboost parameters required for local window classification.
// Default:     {2, 1, 0, 0, -1, 2, 0, -1, 1, 0, -1, 2, 0, 2, 2, 1, 0, 100}.
// Range for each element in 18-D array {-512, ..., 511}
// The classification parameters are optimized in an offline training process.
// Once the parameters are optimized, they remain fixed.
/******************************************************************************/

      /* Demosaic LUT */
      {
         /* wk */
         {
            `xf4a9`,
            `xf4a9`
         },
         /* bk */
         {
            `xi4a9`,
            `xi4a9`
         },
         /* lk */
         {
            `xi4a9`,
            `xi4a9`
         },
         /* Tk */
         {
            `xi4a9`,
            `xi4a9`
         },
      },

/******************************************************************************/
// Applicale chipset(s): 8960, 8x55A and later chipsets.
// Applicable operation mode:
//     Viewfinder, snapshot processing, and video modes.
// 3A mode: N/A.
//
// Variable names: demosic3_aG[2] //HW: 6uQ6
// Green-channel interpolation parameter (2 light conditions).
// Default value: 0.4 (for each light condition).
// Range: [0.3,0.5].
// This parameter is used to control the tradeoff between noise
// suppression and aliasing. A higher value of this variable provides more
// noise suppression but, on the negative side, leads to higher aliasing.
// For best performance, this parameter should be optimized separately for
// low, medium, and high lux-index levels. The default value shown above works
// reasonably well for all lux-index levels, and for both snapshot and
// viewfinder modes.
//
// Variable names: demosic3_bL[2] //HW: 8uQ8
// Green-channel interpolation parameter (2 light conditions).
// Default value: 0.0 (for each light condition).
// Range: [0,0.46].
// In general, a low value of this parameter provides better noise
// suppression while a high value of bL provides better detail preservation.
// For best performance, the parameters should be optimized separately for low,
// medium, and high lux-index levels. The default value shown above works
// reasonably well for all lux-index levels and for both preview and snapshot
// modes.
/******************************************************************************/

      /* aG */
      {
         `xf4`, /* aG[0] */
         `xf4`, /* aG[1] */
      },
      /* bL */
      {
         `xf4`, /* bL[0] */
         `xf4`, /* bL[1] */
      },
   },
   /* Chroma and Luma Filters */
   {
      `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */

/******************************************************************************/
// Feature name : Chroma filter lowlight trigger points.
/******************************************************************************/

      /* Low-Light Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },
      `xu4`, /* Enable Index */

/******************************************************************************/
// Feature name : Chroma filter.
// Applicale chipset(s): 8960, 8x55A and later chipsets.
// Applicable operation mode:
//     Viewfinder, snapshot processing, and video modes.
//  3A mode: N/A.
//
// Variable name: h[4]
// Horizontal component of separable Gaussian filter.
// Default value : {0.1429, 0.1429, 0.1429, 0.142}.
// Range of each component of array: [0,1.0].
// Constraints: h[0]>=h[1] >=h[2] >=h[3]; h[0]+2*h[1]+2*h[2]+2*h[3] = 1.
// Effect: Smoothing amount decreaes as h[1], h[2], and h[3] get smaller.
// The default value shown above works great for all lux-index levels,
// and for both viewfinder and snapshot modes. However, for greater
// flexibility, current recommendation is to tune it separately for different
// lux-index levels.
//
// Variable name: v[2]
// Vertical component of separable Gaussian filter.
// Default value: {0.3333, 0.3333}.
// Range of each component of array [0,1.0].
// Constraints: v[0]>=v[1]; v[0]+2*v[1] = 1.
// Effect: Smoothing amount decreases as v[1] gets smaller.
// The default value shown above works great for all lux-index levels and
// for both viewfinder and snapshot modes. However, for greater flexibility,
// current recommendation is to tune it separately for different lux-index
// levels.
/******************************************************************************/

      /* Filters */
      {
         /* Lowlight Chroma Filter */
         {
            /* H */
            {
               `xf4a4`
            },
            /* V */
            {
               `xf4a2`
            },
         },
         /* Normal Light Chroma Filter */
         {
            /* H */
            {
               `xf4a4`
            },
            /* V */
            {
               `xf4a2`
            },
         },
      },
      `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */

/******************************************************************************/
// Feature name : Luma filter low light trigger points.
/******************************************************************************/

      /* Low-Light Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },

/******************************************************************************/
// Feature name : Luma filter bright light trigger points.
/******************************************************************************/

      /* Bright Light Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },
      `xu4`, /* Enable Index */

/******************************************************************************/
// Feature name : Luma filter low light parameters.
/******************************************************************************/

      /* Luma Filter Low Light */
      {
         /* Thresholds */
         {`xu2a3+2`}, /* 12-bit pixels */
         /* Scale Factors */
         {`xf4a2`},

         /* Positive table */
         {
            `xf4a4`,
            `xf4a4`,
            `xf4a4`,
            `xf4a4`
         },
         /* Negative table */
         {
            `xf4a4`,
            `xf4a4`
         },
      },

/******************************************************************************/
// Feature name : Luma filter normal light parameters.
/******************************************************************************/

      /* Luma Filter Normal Light */
      {
         /* Thresholds */
         {`xu2a3+2`}, /* 12-bit pixels */
         /* Scale Factors */
         {`xf4a2`},

         /* Positive table */
         {
            `xf4a4`,
            `xf4a4`,
            `xf4a4`,
            `xf4a4`
         },
         /* Negative table */
         {
            `xf4a4`,
            `xf4a4`
         },
      },

/******************************************************************************/
// Feature name : Luma filter bright light parameters.
/******************************************************************************/

      /* Luma Filter Bright Light */
      {
         /* Thresholds */
         {`xu2a3+2`}, /* 12-bit pixels */
         /* Scale Factors */
         {`xf4a2`},

         /* Positive table */
         {
            `xf4a4`,
            `xf4a4`,
            `xf4a4`,
            `xf4a4`
         },
         /* Negative table */
         {
            `xf4a4`,
            `xf4a4`
         },
      },
   },
   /* Color Correction */
   {

/*********************************************************************/
// Feature name :
// Use gain or lux_index to control color correction.
// Range: 0 or 1.
// 0 means to use lux_index to control
// 1 means to use gain to control
/*********************************************************************/

      `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */

/*********************************************************************/
// Feature name :
// Trigger point for color correction.
// gain start :
// When gain >= gain_start, lowlight CC is interpolated with normal CC.
// default: N/A
// Range: min_gain to max_gain. Gain means digital and analog combined gain.
// Effect: Increasing this value will use lowlight CC under lower light condition.
//
// gain end:
// When gain >= gain_end, 100% lowlight CC is used.
// default: N/A
// range: min_gain to max_gain. Gain means digital and analog combined gain.
// constraint: gain_end > gain_start.
// effect: Increasing this value will use 100% lowlight CC under lower light condition.
//
// lux_index_start:
// When lux_index >= lux_index_start, lowlight CC is interpolated with normal CC.
// default: N/A
// range: For linear AFR case: 0 to max_index from exposure table.
//		  For non-linear AFR case : 0 to max_index*numberof_FPS_supported.
// effect: Increasing this value will use lowlight CC under lower light condition
//
// lux_index_end:
// When lux_index >= lux_index_end, 100% lowlight CC is used.
// default: N/A
// range: Ror linear AFR case: 0 to max_index from exposure table.
//		  For non-linear AFR case : 0 to max_index*numberof_FPS_supported.
// constraint: lux_index_end > lux_index_start.
// effect: Increasing this value will use 100% lowlight CC under lower light condition.
//
/*********************************************************************/

      /* Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },
      /* A CCT Trigger */
      {

/*********************************************************************/
// Feature name :
// Trigger point for color temperature related control (A).
// Applicable chipset: For all chipsets.
// 3A version: 2.2
// When the color temperature < A_start and > A_end, use interpolation between A and FL.
// When the color temperature >=A_end, just use A parameters.
// Range: 4100 > A_start > A_end > 2850.
// Effect: A_start and A_end controls the range of interpolation between A and FL.
// Constraint: A_start > A_end.
/*********************************************************************/

         `xu4`, /* Start */
         `xu4`, /* End */
      },
      /* D65 CCT Trigger */
      {

/*********************************************************************/
// Feature name :
// Trigger point for color temperature related control (Daylight).
// Applicable chipset: For all chipsets.
// 3A version: 2.2
// When the color temperature > Daylight_start and < Daylight_end, use interpolation between D65 and FL.
// When the color temperature >=D65_end, just use D65 parameters.
// Range: 4100 < Dayligh_start < Dayligh_end < 5000.
// Effect: Daylight_start and Daylight_end controls the range of interpolation between Daylight and FL.
// Constraint: Daylight_start < Daylight_end.
/*********************************************************************/

         `xu4`, /* Start */
         `xu4`, /* End */
      },

/******************************************************************************/
// Feature name: Color Correction Trigger Point for LED Flash
// Applicale chipset(s): ALL with LED Flash
// Applicable operation mode:  Flash Snapshot and ZSL, determined in preview
//
// Variable name: CC_LED_start
// Sets start trigger for interpolation of CC
//     k1 = aec_d->flash_si.off / aec_d->flash_si.high;
// Default value:  1.0
// Data range: 1.0 to 100
// Constraints: None
// Effect: Higher value allows less LED CC to be used
//
// Variable name: CC_LED_end
// Sets end trigger for interpolation of CC
//     k1 = aec_d->flash_si.off / aec_d->flash_si.high;
// Default value:  7.5
// Data range: 1.0 to 100
// Constraints: None
// Effect: Higher value allows less LED CC to be used, value closer to
//     CC_LED_start may cause shot to shot variation due to sudden change in CC
/******************************************************************************/

      `xf4`, /* LED Start */
      `xf4`, /* LED End */

/******************************************************************************/
// Feature name: Color Correction Trigger Point for Xenon Strobe Flash
// Applicale chipset(s): ALL with Strobe Flash
// Applicable operation mode:  Flash Snapshot and ZSL, determined in preview
//
// Variable name: CC_strobe_start
// Sets start trigger for interpolation of CC
//     k1 = aec_d->flash_si.off / aec_d->flash_si.high;
// Default value:  1.0
// Data range: 1.0 to 100
// Constraints: None
// Effect: Higher value allows less Xenon Strobe CC to be used
//
// variable name: CC_strobe_end
// Sets end trigger for interpolation of CC
//     k1 = aec_d->flash_si.off / aec_d->flash_si.high;
// Default value:  7.5
// Data range: 1.0 to 100
// Constraints: None
// Effect: Higher value allows less Xenon Flash CC to be used, value closer to
//     CC_strobe_start may cause shot to shot variation due to sudden change in CC
/******************************************************************************/

      `xf4`, /* Strobe Start */
      `xf4`, /* Strobe End */

/*********************************************************************/
// Feature name :
// Normal and bright light color correction.
// 3x3 coefficients:
// Data range: -15.99 to 15.99.
// Constraint: The sum of each row needs to be 1.
// Effect: Higher diagonal values result in higher color saturation with higher noise.
//
// 3 offsets
// Data range: -1023 to 1023.
// Default : 0
// Effect: Negative values will make image darker while positive values make image brighter.
//
// Q factor:
// Always set it to 0.
/*********************************************************************/

      /* TL84 Color Correction */
      /* Noise Weight: 0.000000 */
      /* Saturation: Red - 1.000000, Green - 1.000000, Blue - 1.000000 */
      {
         `xf4a3`,
         `xf4a3`,
         `xf4a3`,
         `xu2a3`,
         `xu1+1`
      },

/*********************************************************************/
// Feature name :
// Low light color correction.
/*********************************************************************/

      /* Low-Light Color Correction */
      /* Noise Weight: 0.000000 */
      /* Saturation: Red - 1.000000, Green - 1.000000, Blue - 1.000000 */
      {
         `xf4a3`,
         `xf4a3`,
         `xf4a3`,
         `xu2a3`,
         `xu1+1`
      },
      /* D65 Color Correction */
      /* Noise Weight: 0.000000 */
      /* Saturation: Red - 1.000000, Green - 1.000000, Blue - 1.000000 */
      {
         `xf4a3`,
         `xf4a3`,
         `xf4a3`,
         `xu2a3`,
         `xu1+1`
      },
      /* A Color Correction */
      /* Noise Weight: 0.000000 */
      /* Saturation: Red - 1.000000, Green - 1.000000, Blue - 1.000000 */
      {
         `xf4a3`,
         `xf4a3`,
         `xf4a3`,
         `xu2a3`,
         `xu1+1`
      },
      /* Outdoor Color Correction */
      /* Noise Weight: 0.000000 */
      /* Saturation: Red - 1.000000, Green - 1.000000, Blue - 1.000000 */
      {
         `xf4a3`,
         `xf4a3`,
         `xf4a3`,
         `xu2a3`,
         `xu1+1`
      },
      /* LED Flash Color Correction */
      /* Noise Weight: 0.000000 */
      /* Saturation: Red - 1.000000, Green - 1.000000, Blue - 1.000000 */
      {
         `xf4a3`,
         `xf4a3`,
         `xf4a3`,
         `xu2a3`,
         `xu1+1`
      },
      /* Strobe Flash Color Correction */
      /* Noise Weight: 0.000000 */
      /* Saturation: Red - 1.000000, Green - 1.000000, Blue - 1.000000 */
      {
         `xf4a3`,
         `xf4a3`,
         `xf4a3`,
         `xu2a3`,
         `xu1+1`
      },
   },
   /* Gamma Tables */
   {

/*********************************************************************/
// Feature name :
// Control for lowlight gamma.
// 0 means using lux index to control.
// 1 means using gain to control.
/*********************************************************************/

      `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */

/*********************************************************************/
// Feature name :
// Trigger point for lowlight gamma.
// gain start:
// When gain >= gain_start, lowlight gamma is interpolated with normal gamma.
// Range: min_gain to max_gain. Gain means digital and analog combined gain.
// Effect: Increasing this value will use lowlight gamma under lower light condition.
//
// gain end:
// When gain >= gain_end, 100% lowlight gamma is used.
// Range: min_gain to max_gain. Gain means digital and analog combined gain.
// Constraint: gain_end > gain_start.
// Effect: Increasing this value will use 100% lowlight gamma under lower light condition.
//
// lux_index_start:
// When lux_index >= lux_index_start, lowlight gamma is interpolated with normal gamma.
// Range: For linear AFR case: 0 to max_index from exposure table.
//		  For non-linear AFR case : 0 to max_index*numberof_FPS_supported.
// Effect: Increasing this value will use lowlight gamma under lower light condition.
//
// lux_index_end:
// When lux_index >= lux_index_end, 100% lowlight gamma is used.
// Range: For linear AFR case: 0 to max_index from exposure table.
//		  For non-linear AFR case : 0 to max_index*numberof_FPS_supported.
// Constraint: lux_index_end > lux_index_start.
// Effect: Increasing this value will use 100% lowlight gamma under lower light condition.
//
/*********************************************************************/

      /* Low-Light Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },

/*********************************************************************/
// Feature name :
// Trigger point for brightlight gamma.
// gain start :
// When gain <= gain_start, brightlight gamma is interpolated with normal gamma.
// Range: min_gain to max_gain. Gain means digital and analog combined gain.
// Effect: Decreasing this value will use brightlight gamma under brighter light condition.
//
// gain end:
// When gain <= gain_end, 100% brightlight gamma is used.
// Range: min_gain to max_gain. Gain means digital and analog combined gain.
// Constraint: gain_end < gain_start.
// Effect: Decreasing this value will use 100% brightlight gamma under brighter light condition.
//
// lux_index_start:
// When lux_index <= lux_index_start, brightlight gamma is interpolated with normal gamma.
// Range: For linear AFR case: 0 to max_index from exposure table.
//		  For non-linear AFR case : 0 to max_index*numberof_FPS_supported.
// Effect: Decreasing this value will use brightlight gamma under brighter light condition.
//
// lux_index_end:
// When lux_index <= lux_index_end, 100% lowlight gamma is used.
// Range: For linear AFR case: 0 to max_index from exposure table.
//		  For non-linear AFR case : 0 to max_index*numberof_FPS_supported.
// Constraint: lux_index_end < lux_index_start.
// Effect: Decreasing this value will use 100% brightlight gamma under brighter light condition.
//
/*********************************************************************/

      /* Outdoor Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },

/*********************************************************************/
// Feature name :
// Normal light gamma.
// Range: 0 to 255.
//
// linear flag:
// This is a HW flag. Always set this flag to 0.
/*********************************************************************/

      /* Gamma Table */
      /* Gamma Option: Medium, Weight: 0 */
      {
         {
            `xu1a16`,
            `xu1a16`,
            `xu1a16`,
            `xu1a16`
         },
      },

/*********************************************************************/
//Feature name :
// Lowlight light gamma.
// Range: 0 to 255.
//
// linear flag:
// This is a HW flag. Always set this flag to 0.
/*********************************************************************/

      /* Low-Light Gamma Table */
      /* Gamma Option: Medium, Weight: 0 */
      {
         {
            `xu1a16`,
            `xu1a16`,
            `xu1a16`,
            `xu1a16`
         },
      },

/*********************************************************************/
// Feature name :
// Bright light gamma for.
// Range: 0 to 255.
//
// linear flag:
// This is a HW flag.Always set this flag to 0.
/*********************************************************************/

      /* Outdoor Gamma Table */
      /* Gamma Option: Medium, Weight: 0 */
      {
         {
            `xu1a16`,
            `xu1a16`,
            `xu1a16`,
            `xu1a16`
         },
      },
   },
   /* Color Conversion */
   {

/*********************************************************************/
// Feature name :
// use gain or lux_index to control color conversion
// range: 0 or 1.
// 0 means to use lux_index to control
// 1 means to use gain to control
/*********************************************************************/

      `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */

/**************************************************************************************/
// Feature name :
// Trigger point for snapshot and viewfinder color conversion (advanced chroma enhancement).
// gain start :
// When gain >= gain_start, lowlight CV is interpolated with normal CV.
// Range: min_gain to max_gain. Gain means digital and analog combined gain.
// Effect: Increasing this value will use lowlight CV under lower light condition.
//
// gain end:
// When gain >= gain_end, 100% lowlight CV is used.
// Range: min_gain to max_gain. Gain means digital and analog combined gain.
// Constraint: gain_end > gain_start.
// Effect: Increasing this value will use 100% lowlight CV under lower light condition.
//
// lux_index_start:
// When lux_index >= lux_index_start, lowlight CV is interpolated with normal CV.
// Range: For linear AFR case: 0 to max_index from exposure table.
//		  For non-linear AFR case : 0 to max_index*numberof_FPS_supported.
// Effect: Increasing this value will use lowlight CV under lower light condition.
//
// lux_index_end:
// When lux_index >= lux_index_end, 100% lowlight CV is used.
// Range: For linear AFR case: 0 to max_index from exposure table.
//		  For non-linear AFR case : 0 to max_index*numberof_FPS_supported.
// Constraint: lux_index_end > lux_index_start.
// Effect: Increasing this value will use 100% lowlight CV under lower light condition
//
/**************************************************************************************/

      /* Low-Light Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },
      /* A CCT Trigger */
      {
         `xu4`, /* Start */
         `xu4`, /* End */
      },
      /* D65 CCT Trigger */
      {
         `xu4`, /* Start */
         `xu4`, /* End */
      },

/*********************************************************************/
// Feature name :
// Normal light advanced chroma enhancement for snapshot and viewfinder for 7k and 8k.
//
// am, ap,: Color saturation on Cb
// Data range: -3.99 to 3.99. 0.5 is unity.
// Effect: Higher values result in higher color saturation in Cb with higher noise.
//
// cm, cp,: Color saturation on Cr
// Data range: -3.99 to 3.99. 0.5 is unity.
// Effect: Higher values result in higher color saturation in Cr with higher noise.
//
// bm, bp: Certain offset coeffs for Cb calculation.
// Data range: -1023 to 1023.
//
// dm, dp: Certain offset coeffs for Cr calculation.
// Data range: -1023 to 1023.
//
// k_cb, k_cr: Offsets for Cb,Cr, respectively.
// Data range: -1023 to 1023.
// Default: 128.
//
// v0, v1, v2:
// Coefficients from RGB to Y conversion.
// Range: -7.99 to 7.99.
// Constraint: Sum of them needs to be 1.
//
// K offset: Offset to convert from RGB to Y.
// Range: 0 to 255.
// Default : 0.
// Effect: Positive values make image brighter and negative values make image darker.
/*********************************************************************/

      /* TL84 Color Conversion */
      /* Noise Weight: 0.000000 */
      /* Saturation: Red - 1.000000, Green - 1.000000, Blue - 1.000000 */
      {
         {
            /* a_m, a_p */
            `xf4a2`,
            /* b_m, b_p */
            `xf4a2`,
            /* c_m, c_p */
            `xf4a2`,
            /* d_m, d_p */
            `xf4a2`,
            /* k_cb, k_cr */
            `xu2a2`
         },
         {
            /* v0, v1, v2 */
            `xf4a3`,
            /* k */
            `xu2+2`
         }
      },
      /* A Color Conversion */
      /* Noise Weight: 0.000000 */
      /* Saturation: Red - 1.000000, Green - 1.000000, Blue - 1.000000 */
      {
         {
            /* a_m, a_p */
            `xf4a2`,
            /* b_m, b_p */
            `xf4a2`,
            /* c_m, c_p */
            `xf4a2`,
            /* d_m, d_p */
            `xf4a2`,
            /* k_cb, k_cr */
            `xu2a2`
         },
         {
            /* v0, v1, v2 */
            `xf4a3`,
            /* k */
            `xu2+2`
         }
      },
      /* D65 Color Conversion */
      /* Noise Weight: 0.000000 */
      /* Saturation: Red - 1.000000, Green - 1.000000, Blue - 1.000000 */
      {
         {
            /* a_m, a_p */
            `xf4a2`,
            /* b_m, b_p */
            `xf4a2`,
            /* c_m, c_p */
            `xf4a2`,
            /* d_m, d_p */
            `xf4a2`,
            /* k_cb, k_cr */
            `xu2a2`
         },
         {
            /* v0, v1, v2 */
            `xf4a3`,
            /* k */
            `xu2+2`
         }
      },
      /* Yhi-Ylo Color Conversion */
      /* Noise Weight: 0.000000 */
      /* Saturation: Red - 1.000000, Green - 1.000000, Blue - 1.000000 */
      {
         {
            /* a_m, a_p */
            `xf4a2`,
            /* b_m, b_p */
            `xf4a2`,
            /* c_m, c_p */
            `xf4a2`,
            /* d_m, d_p */
            `xf4a2`,
            /* k_cb, k_cr */
            `xu2a2`
         },
         {
            /* v0, v1, v2 */
            `xf4a3`,
            /* k */
            `xu2+2`
         }
      },
      /* Outdoor Color Conversion */
      /* Noise Weight: 0.000000 */
      /* Saturation: Red - 1.000000, Green - 1.000000, Blue - 1.000000 */
      {
         {
            /* a_m, a_p */
            `xf4a2`,
            /* b_m, b_p */
            `xf4a2`,
            /* c_m, c_p */
            `xf4a2`,
            /* d_m, d_p */
            `xf4a2`,
            /* k_cb, k_cr */
            `xu2a2`
         },
         {
            /* v0, v1, v2 */
            `xf4a3`,
            /* k */
            `xu2+2`
         }
      },
      /* Monochrome Color Conversion */
      {
         {
            /* a_m, a_p */
            `xf4a2`,
            /* b_m, b_p */
            `xf4a2`,
            /* c_m, c_p */
            `xf4a2`,
            /* d_m, d_p */
            `xf4a2`,
            /* k_cb, k_cr */
            `xu2a2`
         },
         {
            /* v0, v1, v2 */
            `xf4a3`,
            /* k */
            `xu2+2`
         }
      },
      /* Sepia Color Conversion */
      {
         {
            /* a_m, a_p */
            `xf4a2`,
            /* b_m, b_p */
            `xf4a2`,
            /* c_m, c_p */
            `xf4a2`,
            /* d_m, d_p */
            `xf4a2`,
            /* k_cb, k_cr */
            `xu2a2`
         },
         {
            /* v0, v1, v2 */
            `xf4a3`,
            /* k */
            `xu2+2`
         }
      },
      /* Negative Color Conversion */
      {
         {
            /* a_m, a_p */
            `xf4a2`,
            /* b_m, b_p */
            `xf4a2`,
            /* c_m, c_p */
            `xf4a2`,
            /* d_m, d_p */
            `xf4a2`,
            /* k_cb, k_cr */
            `xu2a2`
         },
         {
            /* v0, v1, v2 */
            `xf4a3`,
            /* k */
            `xu2+2`
         }
      },
      /* Aqua Color Conversion */
      {
         {
            /* a_m, a_p */
            `xf4a2`,
            /* b_m, b_p */
            `xf4a2`,
            /* c_m, c_p */
            `xf4a2`,
            /* d_m, d_p */
            `xf4a2`,
            /* k_cb, k_cr */
            `xu2a2`
         },
         {
            /* v0, v1, v2 */
            `xf4a3`,
            /* k */
            `xu2+2`
         }
      },
      `xf4`, /* Saturated Color Conversion Factor */
   },
   /* 5x5 ASF */
   {

/*********************************************************************/
// Feature name :
// Use gain or lux_index to control ASF
// Range: 0 or 1.
// 0 means to use lux_index to control.
// 1 means to use gain to control.
/*********************************************************************/

      `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */

/*********************************************************************/
// Feature name :
// Trigger point for 5x5ASF.
// This set of parameters is used for all chipsets.
// gain start :
// When gain >= gain_start, lowlight ASF is interpolated with normal ASF.
// Range: min_gain to max_gain. Gain means digital and analog combined gain.
// Effect: Increasing this value will use lowlight ASF under lower light condition.
//
// gain end:
// When gain >= gain_end, 100% lowlight ASF is used.
// Range: min_gain to max_gain. Gain means digital and analog combined gain.
// Constraint: gain_end > gain_start.
// Effect: Increasing this value will use 100% lowlight ASF under lower light condition.
//
// lux_index_start:
// When lux_index >= lux_index_start, lowlight ASF is interpolated with normal ASF.
// Range: For linear AFR case: 0 to max_index from exposure table.
//		  For non-linear AFR case : 0 to max_index*numberof_FPS_supported.
// Effect: Increasing this value will use lowlight ASF under lower light condition.
//
// lux_index_end:
// When lux_index >= lux_index_end, 100% lowlight ASF is used.
// Range: For linear AFR case: 0 to max_index from exposure table.
//		  For non-linear AFR case : 0 to max_index*numberof_FPS_supported.
// Constraint: lux_index_end > lux_index_start.
// Effect: Increasing this value will use 100% lowlight ASF under lower light condition.
//
/*********************************************************************/

      /* Low-Light Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },

/*********************************************************************/
// Feature name :
// Trigger point for brightlight 5x5 ASF.
// This set of parameters is used for all chipsets.
// gain start :
// When gain <= gain_start, brightlight ASF is interpolated with normal ASF.
// Range: min_gain to max_gain. Gain means digital and analog combined gain.
// Effect: Decreasing this value will use brightlight ASF under brighter light condition.
//
// gain end:
// When gain <= gain_end, 100% brightlight ASF is used.
// Range: min_gain to max_gain. Gain means digital and analog combined gain.
// Constraint: gain_end < gain_start.
// Effect: Decreasing this value will use 100% brightlight ASF under brighter light condition.
//
// lux_index_start:
// When lux_index <= lux_index_start, brightlight ASF is interpolated with normal ASF.
// Range: For linear AFR case: 0 to max_index from exposure table.
//		  For non-linear AFR case : 0 to max_index*numberof_FPS_supported.
// Effect: Decreasing this value will use brightlight ASF under brighter light condition.
//
// lux_index_end:
// When lux_index <= lux_index_end, 100% lowlight ASF is used.
// Range: For linear AFR case: 0 to max_index from exposure table.
//		  For non-linear AFR case : 0 to max_index*numberof_FPS_supported.
// Constraint: lux_index_end < lux_index_start.
// Effect: Decreasing this value will use 100% brightlight ASF under brighter light condition.
//
/*********************************************************************/

      /* Outdoor Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },

/*********************************************************************/
// Feature name :
// 5x5 ASF filter mode.
// This set of parameters is used for all chipsets with some exceptions, please see each item for details.
// 0 means ASF is off.
// 1 means single 5x5 ASF filter.
// 2 means two 5x5 ASF filters.
// 3 means smart mode. Currently software does not support this mode.
// Default: 2
//
//Please do not change smoothing filter and Laplacian filter.
//
// Normalization factors for horizontal and veritical directions.
// mode.
// Constraint: It has to be the inverse value of the center cofficient in
//				sharpening filter for horizontal and vertical directions,
//				respectively.
//
// Sharpening coeff. for horizontal and vertical directions, respectively.
// These parameters are used for all chipsets.
// Range: Middle coeff -63.9 to 63, surounding ceoff -127 to 127.
// Constraints: All coffs need to sum to 0.
//
// Extraction factor is not supported by software.
//
// 5x5 ASF parameters under lowlight, normal, and bright light.
//
// e1
// Noise threshold.
// It is for all chipsets.
// Range: 0 to 127.
// Effect: Smaller value will result in more edges to be sharpened.
//
// e2
// Sharpening Limit
// Range: 0 to 127.
// Constraint: e2>=e1.
// Effect: Larger values will result in sharper strong edges.
// For MSM7601, MSM7201, MSM7501, e2 affects horizontal and vertical edges.
// For QSD8x50, QSC6270(6240), QSC6295, e2 only affects horizontal positive edges.
//
// e3
// Sharpening limit for horizontal negative edge.
// e3 is only supported on QSD8x50, QSC6270(6240), QSC6295, MSM7x25, MSM7x27.
// Default: -e2
// Range: -128 to 0.
// Constraints: |e3| >= e1.
// Effect: Smaller values will result in sharper negative strong edges.
//
// e4
// Sharpening limit for vertical positive edge.
// e4 is only supported on QSD8x50, QSC6270(6240), QSC6295, MSM7x25, MSM7x27.
// Default: e2.
// Range: 0 to 127
// Constraints: e4 >= e1.
// Effect: Larger values will result in sharper positive strong edges.
//
// e5
// Sharpening limit for vertical negative edge.
// e5 is only supported on QSD8x50, QSC6270(6240), QSC6295, MSM7x25, MSM7x27.
// Default: -e4.
// Range: -128 to 0.
// Constraints: |e5| >= e1.
// Effect: Smaller values will result in sharper negative strong edges.
//
// k1 and k2
// Sharpening degree for horizontal and vertical edges.
// These are supported in all chipsets.
// Range: 0 to 3.9. (except for sROC; on sROC max value is 1.9.)
// Effect: Larger value result in sharper edges.
//
// sp
// Smoothing percentage.
// It is for all chipsets.
// Range: 0 to 100.
// Effect: Larger value results in smoother images.
//
/*********************************************************************/

      /* 5x5 ASF */
      {
         `xu4`, /* Filter Mode */
         `xf4`, /* Normalize Factor 1 */
         `xf4`, /* Normalize Factor 2 */
         /* 5x5 Filter 1 */
         {
            `xi2a5`,
            `xi2a5`,
            `xi2a5`,
            `xi2a5`,
            `xi2a5`
         },
         /* 5x5 Filter 2 */
         {
            `xi2a5`,
            `xi2a5`,
            `xi2a5`,
            `xi2a5`,
            `xi2a5`
         },
         `xu1+3`, /* Extraction Factor */
         /* Settings */
         {
            /* Low Light */
            {
               `xi1`, /* e1 */
               `xi1`, /* e2 */
               `xi1`, /* e3 */
               `xi1`, /* e4 */
               `xi1+3`, /* e5 */
               `xf4`, /* k1 */
               `xf4`, /* k2 */
               `xi1`, /* sp */
               `xi1+2`, /* sp 5x5 */
            },
            /* Normal Light */
            {
               `xi1`, /* e1 */
               `xi1`, /* e2 */
               `xi1`, /* e3 */
               `xi1`, /* e4 */
               `xi1+3`, /* e5 */
               `xf4`, /* k1 */
               `xf4`, /* k2 */
               `xi1`, /* sp */
               `xi1+2`, /* sp 5x5 */
            },
            /* Bright Light */
            {
               `xi1`, /* e1 */
               `xi1`, /* e2 */
               `xi1`, /* e3 */
               `xi1`, /* e4 */
               `xi1+3`, /* e5 */
               `xf4`, /* k1 */
               `xf4`, /* k2 */
               `xi1`, /* sp */
               `xi1+2`, /* sp 5x5 */
            }
         }
      },

/*********************************************************************/
// Feature name :
// Soft focus degree.
// This parameter is used for portrait mode under Best Shot Mode.
// Range: 0.5 to 1.
// Effect: Smaller value will result in softer focus.
/*********************************************************************/

      `xf4`, /* Soft Focus Degree */

/*********************************************************************/
// Feature name :
// Sharpness control parameters per upscaling for 5x5 ASF.
// This parameter is used for all chipsets.
// Range: 0.25 to 1.
// Effect: Larger value will result in little sharpening change for upscaling.
//		   Setting it to 1 will use the same sharpening for upscaling case as
//		   no scaling.
//
/*********************************************************************/

      `xf4`, /* 5x5 Sharp Min DS Factor */

/*********************************************************************/
// Feature name :
// Sharpness control parameters per downscaling for 5x5 ASF.
// This parameter is used for all chipsets.
// We do not recommend changing this value.
/*********************************************************************/

      `xf4`, /* 5x5 Sharp Max DS Factor */

/*********************************************************************/
// Feature name :
// Sharpness control parameters per downscaling for 5x5 ASF.
// This parameter is used for all chipsets.
// Range: 1 to 3.
// Effect: Larger value will result in more sharpening for downscaling case.
// Default value (target-specific): 1 for QSC6xxx, QSD8xxx and MSM7201, MSM7601, MSM7501, MSM7x30, 2 for MSM7x25, MSM7x27.
/*********************************************************************/

      `xf4`, /* 5x5 Sharp Max Factor */
   },
   /* 7x7 ASF */
   {
      `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */
      /* Low-Light Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },
      /* Bright Light Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },

/*********************************************************************/
// VFE4 7x7 ASF filter
//
// 7x7 ASF parameters under lowlight, normal, and bright
// light.
//
// Variable name: SP.
// 3x3 cross type median filter smoothing percentage.
// Data range: 0 to 100.
// Effect: Larger value results in smoother images.
//
// 7x7 edge detection (F1: horizontal & F2: vertical), sharpening
// (F3: horizontal & F4: vertical), and smoothing (F5) coefficients.
// Altered kernel symmatry by (negation & zero)'s according to zones:
// (nz flags are defaulted to 0s, i.e., no change.)
// nz[0]          |nz[1]|          nz[2]
//        0  1  2 |   3 |  2  1  0
//        4  5  6 |   7 |  6  5  4
//        8  9 10 |  11 | 10  9  8
// ---------------+-----+---------------
// nz[7] 12 13 14 |  15 | 14 13 12 nz[3]
// ---------------+-----+---------------
//        8  9 10 |  11 | 10  9  8
//        4  5  6 |   7 |  6  5  4
//        0  1  2 |   3 |  2  1  0
// nz[6]          |nz[5]|          nz[4]
// Data range: Center coeff -2047 to 2047, axes coeff -1023 to 1023,
//        quadrant ceoff -511 to 511.  All are Q10 numbers.
// Constraints: After mirroring, all 49 coefficients in the high-pass
//        filters must sum up to 0, and all 49 coefficients in F5 must
//        sum up to 1.0.
//
//        For MSM8974 (VFE4.0), F1 to F5 must have the same coefficient
//        symmetry, i.e., F1 to F4 should be 2nd order HPFs and F5 be
//        LPF.  For VFE4.1 and after, F1 and F2 can have independent
//        symmetries, i.e., 1st order HPFs.
//
// Variable name: LUT1
// Horizontal edge endhancement strength with noise threshold.
// Data range: 24-entry LUT mapping from absolute edge detection [0, 95] of
//        F1 to edge enhancement strength [0, 7.96] for F3.
// Effect: This mapping curve is optimized with the 7x7 edge sharpening
//        filter.  Small edges due to noise can be thresholded by curve
//        being 0.
//
// Variable name: LUT2
// Vertical edge endhancement strength with noise threshold.
// Data range: 24-entry LUT mapping from absolute edge detection [0, 95] of
//        F2 to edge enhancement strength [0, 7.96] for F4.
// Effect: This mapping curve is optimized with the 7x7 edge sharpening
//        filter.  Small edges due to noise can be thresholded by curve
//        being 0.
//
// Variable name: LUT3
// HPF weighting curve.
// Data range: 12-entry LUT mapping from absolute edge detection [0, 47] of
//        F1+F2 to unsharp HPF output wighting [0, 1.0] of F3+F4.
// Effect: This mapping curve is optimized with the 7x7 edge sharpening
//        filter.  HPF image is blended with LPF image by convex
//        combination, where the output of LPF F5 is weighted as
//        (1.0 - HPF weighting).
//
// Variable names: Smax, Smin
// Ratio to the maximum and minimum in neighborhood for dynamic
// high-end and low-end clamping of edge enhancement.
// Data range: 0 to 7.9.
// Effect: Smax applies to the difference of the maximum in 3x3 diamond
//        neighborhood of the input pixel to the center pixel after 3x3
//        cross-type median filter for high-end clamping level, and
//        Smin similarly applies to the difference of the minimum in
//        neighborhood for low-end clamping level.  Increasing Smax and
//        Smin allow wider swing of edge enhancement proportionally,
//        and vice versa for narrower edge enhancement range.  Dynamic
//        clamping helps reducing edge overshoots to avoid halo
//        artifacts.  The high and low clamping levels apply to
//        horizontal and vertical edge enhancements equally.
//
// Variable names: Omax, Omin
// Offset to the maximum and minimum in neighborhood for dynamic
// high-end and low-end clamping of edge enhancement.
// Data range: 0 to 127.
// Effect: Similar to Smax and Smin, Omax adds offset to the high-end
//        dynamic clamping level and Omin subtracts to the low-end
//        dynamic clamping level.  Increasing Omax and Omin increases
//        the swing range of edge enhancement and vice versa.  The high
//        and low clamping levels apply to horizontal and vertical edge
//        enhancements equally.
//
// Variable names: Clamp_HH, Clamp_HL
// Static high-end and low-end clamping levels of horizontal edge
// enhancement.
// Data range: -255 to 255.
// Effect: If dynamic clamping is disabled, these values are applied to
//        limit the high-end and low-end swing range of edge
//        enhancement of F3 in horizontal direction.
//
// Variable names: Clamp_VH, Clamp_VL
// Static high-end and low-end clamping levels of vertical edge
// enhancement.
// Data range: -255 to 255.
// Effect: If dynamic clamping is disabled, these values are applied to
//        limit the high-end and low-end swing range of edge
//        enhancement of F4 in vertical direction.
//
// Variable names: en_sp_eff, neg_abs_y1, nz[7::0]
// Special effects (emboss, sketch, neon) only.  For normal edge
// enhancement, these should be set to zero.
/*********************************************************************/

      /* 7x7 ASF */
      {
         `xu1+3`, /* Enable */
         /* 3x3 Smooth Percentage */
         {
            `xu4`, /* Lowlight */
            `xu4`, /* Normal Light */
            `xu4`  /* Bright Light */
         },
         `xu1`, /* Enable Special Effects */
         `xu1+2`, /* neg_abs_y1 */
         {`xu4a3`}, /* nz [0] for F1, [1] for F2, [2] for F3 and F4 */
         /* F1 */
         {
            /* Lowlight */
            {
               `xf4a4`,
               `xf4a4`,
               `xf4a4`,
               `xf4a4`
            },
            /* Normal Light */
            {
               `xf4a4`,
               `xf4a4`,
               `xf4a4`,
               `xf4a4`
            },
            /* Bright Light */
            {
               `xf4a4`,
               `xf4a4`,
               `xf4a4`,
               `xf4a4`
            },
         },
         /* F2 */
         {
            /* Lowlight */
            {
               `xf4a4`,
               `xf4a4`,
               `xf4a4`,
               `xf4a4`
            },
            /* Normal Light */
            {
               `xf4a4`,
               `xf4a4`,
               `xf4a4`,
               `xf4a4`
            },
            /* Bright Light */
            {
               `xf4a4`,
               `xf4a4`,
               `xf4a4`,
               `xf4a4`
            },
         },
         /* F3 */
         {
            /* Lowlight */
            {
               `xf4a4`,
               `xf4a4`,
               `xf4a4`,
               `xf4a4`
            },
            /* Normal Light */
            {
               `xf4a4`,
               `xf4a4`,
               `xf4a4`,
               `xf4a4`
            },
            /* Bright Light */
            {
               `xf4a4`,
               `xf4a4`,
               `xf4a4`,
               `xf4a4`
            },
         },
         /* F4 */
         {
            /* Lowlight */
            {
               `xf4a4`,
               `xf4a4`,
               `xf4a4`,
               `xf4a4`
            },
            /* Normal Light */
            {
               `xf4a4`,
               `xf4a4`,
               `xf4a4`,
               `xf4a4`
            },
            /* Bright Light */
            {
               `xf4a4`,
               `xf4a4`,
               `xf4a4`,
               `xf4a4`
            },
         },
         /* F5 */
         {
            `xf4a4`,
            `xf4a4`,
            `xf4a4`,
            `xf4a4`
         },
         /* H / Lut1 */
         {
            /* Lowlight */
            {
               `xf4a6`,
               `xf4a6`,
               `xf4a6`,
               `xf4a6`
            },
            /* Normal Light */
            {
               `xf4a6`,
               `xf4a6`,
               `xf4a6`,
               `xf4a6`
            },
            /* Bright Light */
            {
               `xf4a6`,
               `xf4a6`,
               `xf4a6`,
               `xf4a6`
            },
         },
         /* V / Lut2 */
         {
            /* Lowlight */
            {
               `xf4a6`,
               `xf4a6`,
               `xf4a6`,
               `xf4a6`
            },
            /* Normal Light */
            {
               `xf4a6`,
               `xf4a6`,
               `xf4a6`,
               `xf4a6`
            },
            /* Bright Light */
            {
               `xf4a6`,
               `xf4a6`,
               `xf4a6`,
               `xf4a6`
            },
         },
         {`xi4a3`}, /* Enable Dynamic Clamping */
         {`xf4a3`}, /* smax */
         {`xi4a3`}, /* omax */
         {`xf4a3`}, /* smin */
         {`xi4a3`}, /* omin */
         {`xi4a3`}, /* reg_hh */
         {`xi4a3`}, /* reg_hl */
         {`xi4a3`}, /* reg_vh */
         {`xi4a3`}, /* oreg_vlmin */
         /* Lut3 */
         {
            /* Lowlight */
            {
               `xf4a6`,
               `xf4a6`
            },
            /* Normal Light */
            {
               `xf4a6`,
               `xf4a6`
            },
            /* Bright Light */
            {
               `xf4a6`,
               `xf4a6`
            },
         },
      },
      `xf4`, /* 7x7 Soft Focus Degree */
      `xf4`, /* 7x7 Sharp Min DS Factor */
      `xf4`, /* 7x7 Sharp Max DS Factor */
      `xf4`, /* 7x7 Sharp Max Factor */
   },
   /* Luma Adaptation */
   {
      `xu4`, /* Luma Adaptation Enable */
      `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */

/******************************************************************************/
// Feature name : Luma Adaptation bright light trigger points
//
/******************************************************************************/

      /* Bright Light Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },

/******************************************************************************/
// Feature name: Luma Adaptation (LA) ARM Processing
// applicale chipset(s): QSD8x50, MSM7x30, QSD8x60, MSM8960, MSM8974
// applicable operation mode:
//     QSD8x50: Snapshot processing mode only
//     MSM7x30, QSD8x60, MSM8960, MSM8974: Viewfinder, snapshot, and video
//     modes
//
// variable name: shadow_range.
// Defines the range of low light shadow.
// Default value: 70.
// Data range: 1 to 127.
// Effect: shadow_range defines the low light boost range [0, shadow_range].
//     Shadow pixels on the 0 end are enhanced more than the shadow_range end.
//
// Variable name: shadow_boost_allowance.
// Index for the strength of shadow boost.
// Default value: 0.
// Data range: 0 to 100.
// Constraints:
// Effect: Increasing shadow_boost_allowance will allow stronger shadow boost,
//     and vice versa.  shadow_boost_allowance can be proportional to backlight
//     ratio.
//
// Variable name: LA_reduction_fine_tune.
// Fine tune parameter to reduce overall luma enhancement.
// Default value: 0.
// Data range: 0 to 100.
// Effect: Increasing LA_reduction_fine_tune will decrease overall luma
//     enhancement effects, and vice versa.
//
// Variable name: shadow_boost_fine_tune.
// Fine tune parameter to boost the shadow luminance.
// Default value: 0.
// Data range: 0 to 100.
// Effect: Increasing shadow_boost_fine_tune will make shadow area brighter,
//     and vice versa.
//
// Variable name: highlight_suppress_fine_tune.
// Fine tune parameter to enhance the highlight details.
// Default value: 0.
// Data range: 0 to 100.
// Effect: Increasing highlight_suppress_fine_tune will make highlight regions
//     darker, and vice versa.
/******************************************************************************/

      /* Indoor Luma Adaptation */
      {
         `xu1`, /* Shadow Range */
         `xu1`, /* Shadow Boost Allowance */
         `xu1`, /* Reduction Fine Tune */
         `xu1`, /* Highlight Supress Fine Tune */
         `xu1`, /* Shadow Boost Fine Tune */
      },
      /* Outdoor Luma Adaptation */
      {
         `xu1`, /* Shadow Range */
         `xu1`, /* Shadow Boost Allowance */
         `xu1`, /* Reduction Fine Tune */
         `xu1`, /* Highlight Supress Fine Tune */
         `xu1+2`, /* Shadow Boost Fine Tune */
      },
      `xi4`, /* Luma Target Adjust */
   },
   /* Chroma Suppression/Memory Color Enhancement */
   {

/*********************************************************************/
// Feature name :
// Use gain or lux_index to control chroma suppression (CS).
// Range: 0 or 1.
// 0 means to use lux_index to control.
// 1 means to use gain to control.
/*********************************************************************/

      `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */

/*********************************************************************/
// Feature name :
// Trigger point for chroma suppression (CS)
// gain start:
// When gain >= gain_start, lowlight CS is interpolated with normal CS.
// Range: min_gain to max_gain. Gain means digital and analog combined gain.
// Effect: Increasing this value will use lowlight CS under lower light condition.
//
// gain end:
// When gain >= gain_end, 100% lowlight CS is used.
// Range: min_gain to max_gain. Gain means digital and analog combined gain.
// Constraint: gain_end > gain_start.
// Effect: Increasing this value will use 100% lowlight CS under lower light condition.
//
// lux_index_start:
// When lux_index >= lux_index_start, lowlight CS is interpolated with normal CS.
// Range: For linear AFR case: 0 to max_index from exposure table.
//		  For non-linear AFR case : 0 to max_index*numberof_FPS_supported.
// Effect: Increasing this value will use lowlight CS under lower light condition.
//
// lux_index_end:
// When lux_index >= lux_index_end, 100% lowlight CS is used.
// Range: For linear AFR case: 0 to max_index from exposure table.
//		  For non-linear AFR case : 0 to max_index*numberof_FPS_supported.
// Constraint: lux_index_end > lux_index_start.
// Effect: Increasing this value will use 100% lowlight CS under lower light condition.
//
/*********************************************************************/

      /* Low-Light Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },

/*********************************************************************/
// Feature name :
// CS parameters for lowlight.
//
// Luma Threshold 1 and Luma Threshold 2
// Range: 0 to 255.
// Constraint: For 7x30 and later,
//             4 <= (threshold2 - threshold1) <= 127
//             For earlier chips,
//             (threshold2 - threshold1) > 0 and is a power of 2.
// Effect: Larger (threshold2 - threshold1) tends to result in more dark pixels
//         to be pulled towards grey.
//
// Luma Threshold 3 and Luma Threshold 4
// Range: 0 to 255.
// Constraint: For 7x30 and later,
//             4 <= (threshold4 - threshold3) <= 127
//             For earlier chips,
//             (threshold4 - threshold3) > 0 and is a power of 2.
// Effect: Larger (threshold4 - threshold3) tends to result in more bright pixels
//         to be pulled towards grey.
//
// Chroma Threshold 1 and Chroma Threshold 2
// Range: 0 to 255.
// Constraint: For 7x30 and later,
//             4 <= (threshold2 - threshold1) <= 127
//             For earlier chips,
//             (threshold2 - threshold1) > 0 and is a power of 2.
// Effect: Larger (threshold2 - threshold1) tends to result in more color pixels
//         to be pulled towards grey.
//
/*********************************************************************/

      /* Low-Light Chroma Suppression */
      {
         `xu1`, /* Luma Threshold 1 */
         `xu1`, /* Luma Threshold 2 */
         `xu1`, /* Luma Threshold 3 */
         `xu1`, /* Luma Threshold 4 */
         `xu1`, /* Chroma Threshold 1 */
         `xu1`, /* Chroma Threshold 2 */
      },

/*********************************************************************/
// Feature name : CS parameters.
// CS parameters for normal light.
// Please see details under lowlight.
/*********************************************************************/

      /* Chroma Suppression */
      {
         `xu1`, /* Luma Threshold 1 */
         `xu1`, /* Luma Threshold 2 */
         `xu1`, /* Luma Threshold 3 */
         `xu1`, /* Luma Threshold 4 */
         `xu1`, /* Chroma Threshold 1 */
         `xu1`, /* Chroma Threshold 2 */
      },

/*********************************************************************/
// Feature name : Chroma threshold for strong chroma suppression (CS).
// Variable name: chroma_thresh_BW.
// When max chroma < chroma_thresh_BW, strong CS will be used.
// Default value: 40.
// Data range: 0 to 127.
// Effect: Increasing this value will make image more likely to use strong chroma suppression.
//
// Feature name : Chroma threshold for regualr chroma suppression (CS).
// Variable name: chroma_thresh_color.
// When max chroma > chroma_thresh_color, regualr CS will be used.
// Default value: 60.
// Data range: 0 to 127.
// Effect: Increasing this value will make image less likely to use regular chroma suppression.
/*********************************************************************/

      `xu1`, /* Chroma Thresh BW */
      `xu1+2`, /* Chroma Thresh Color */

/******************************************************************************/
// Feature name : MCE (Memory Color Enhancement)
// RGB color gains and their corresponding color boundary & transition zone
// applicale chipset(s): 7X30, 8660, 867x
// applicable operation mode: preivew and snapshot
// effect: larger boost factor --> lager color saturation
//
// variable name: green_y
// Adjustment point in Y
// default value: {20, 40, 200, 235}
// data range: 0-255
// constraints: 0-255
// effect: adjust the boost factor relative to Y
//
// variable name: green_boost_factor
// Max boost factor for green
// default value: 1.0
// data range: 1.0 - 2.0
// constraints: 1.0 - 2.0
// effect: larger vale --> greener
//
// variable name: green_cr_boundary
// Cr boundary for green
// default value: default = -10
// data range: -127 to 127
// constraints: green zone should not overlap with other color zones
// effect: size of the green zone, more negative --> smaller green zone
//
// variable name: green_cb_boundary
// Cb boundary for green
// default value: -12
// data range: -127 to 127
// constraints: green zone should not overlap with other color zones
//              must be same as green_cr_boundary
// effect: size of the green zone, more negative --> smaller green zone
//
// variable name: green_cr_transition_width
// Transition zone width for Cr boundary for green
// default value: 8
// data range: 4 to 31
// constraints: green zone should not overlap with other color zones
// effect: Cr width of the green zone transition, larger-> smoother change
//
// variable name: green_cb_transition_width
// Transition zone width for Cb boundary for green
// default value: 8
// data range: 4 to 31
// constraints: green zone should not overlap with other color zones
// effect: Cb width of the green zone transition, larger-> smoother change
//
// variable name: green_bright_index
// Exposure index for full green boosting effect
// default value (calculated) : AEC outdoor index
// data range: 0 to max exp index
// constraints: < green_dark_index
// effect: adjust the exposure level for full green boosting effect.
//
// variable name: green_dark_index
// Exposure index for no green boosting effect
// default value: default (calculated): (AEC indoor index+AEC outdoor index)/2
// data range: 0 to max exp index
// constraints: > green_bright_index
// effect: adjust the exposure level for no green boosting effect.
//
// variable name: blue_y
// Adjustment point in Y
// default value: {80, 150, 235, 255}
// data range: 0-255
// constraints: 0-255
// effect: adjust the boost factor relative to Y
//
// variable name: blue_boost_factor
// Max boost factor for blue
// default value: 1.0
// data range: 1.0 - 2.0
// constraints: 1.0 - 2.0
// effect: larger vale --> bluer
//
// variable name: blue_cr_boundary
// Cr boundary for blue
// default value: default = -18
// data range: -127 to 127
// constraints: blue zone should not overlap with other color zones
// effect: size of the blue zone, more negative --> smaller blue zone
//
// variable name: blue_cb_boundary
// Cb boundary for blue
// default value: 25
// data range: -127 to 127
// constraints: blue zone should not overlap with other color zones
//              must be same as blue_cr_boundary
// effect: size of the blue zone, more positive --> smaller blue zone
//
// variable name: blue_cr_transition_width
// Transition zone width for Cr boundary for blue
// default value: 10
// data range: 4 to 31
// constraints: blue zone should not overlap with other color zones
// effect: Cr width of the blue zone transition, larger-> smoother change
//
// variable name: blue_cb_transition_width
// Transition zone width for Cb boundary for blue
// default value: 10
// data range: 4 to 31
// constraints: blue zone should not overlap with other color zones
// effect: Cb width of the blue zone transition, larger-> smoother change
//
// variable name: blue_bright_index
// Exposure index for full blue boosting effect
// default value (calculated) : AEC outdoor index
// data range: 0 to max exp index
// constraints: < blue_dark_index
// effect: adjust the exposure level for full blue boosting effect.
//
// variable name: blue_dark_index
// Exposure index for no blue boosting effect
// default value: default (calculated): (AEC indoor index+AEC outdoor index)/2
// data range: 0 to max exp index
// constraints: > blue_bright_index
// effect: adjust the exposure level for no blue boosting effect.
//
// variable name: red_y
// Adjustment point in Y
// default value: {10, 30, 200, 235}
// data range: 0-255
// constraints: 0-255
// effect: adjust the boost factor relative to Y
//
// variable name: red_boost_factor
// Max boost factor for red
// default value: 1.0
// data range: 1.0 - 2.0
// constraints: 1.0 - 2.0
// effect: larger vale --> redder
//
// variable name: red_cr_boundary
// Cr boundary for red
// default value: 45
// data range: -127 to 127
// constraints: red zone should not overlap with other color zones
// effect: size of the red zone, more positive --> smaller red zone.
//
// variable name: red_cb_boundary
// Cb boundary for red
// default value: 127
// data range: -127 to 127
// constraints: red zone should not overlap with other color zones
//              must be same as red_cr_boundary
// effect: size of the red zone, more positive --> larger red zone
//
// variable name: red_cr_transition_width
// Transition zone width for Cr boundary for red
// default value: 10
// data range: 4 to 31
// constraints: red zone should not overlap with other color zones
// effect: Cr width of the red zone transition, larger-> smoother change
//
// variable name: red_cb_transition_width
// Transition zone width for Cb boundary for red
// default value: 10
// data range: 4 to 31
// constraints: red zone should not overlap with other color zones
// effect: Cb width of the red zone transition, larger-> smoother change
//
// variable name: red_bright_index
// Exposure index for full red boosting effect
// default value (calculated) : AEC outdoor index
// data range: 0 to max exp index
// constraints: < red_dark_index
// effect: adjust the exposure level for full red boosting effect.
//
// variable name: red_dark_index
// Exposure index for no red boosting effect
// default value (calculated): (AEC indoor index+AEC outdoor index)/2
// data range: 0 to max exp index
// constraints: > red_bright_index
// effect: adjust the exposure level for no red boosting effect.
/******************************************************************************/

      /* Memory Color Enhancement */
      {
         {`xu1a4`}, /* green y */
         `xf4`, /* green boost factor */
         `xi1`, /* green cr boundary */
         `xi1`, /* green cb boundary */
         `xi1`, /* green cr transition width */
         `xi1`, /* green cb transition width; ignored, green cr transition width used */
         `xu2`, /* green bright index */
         `xu2`, /* green dark index */

         {`xu1a4`}, /* blue y */
         `xf4`, /* blue boost factor */
         `xi1`, /* blue cr boundary */
         `xi1`, /* blue cb boundary */
         `xi1`, /* blue cr transition width */
         `xi1`, /* blue cb transition width; ignored, blue cr transition width used */
         `xu2`, /* blue bright index */
         `xu2`, /* blue dark index */

         {`xu1a4`}, /* red y */
         `xf4`, /* red boost factor */
         `xi1`, /* red cr boundary */
         `xi1`, /* red cb boundary */
         `xi1`, /* red cr transition width */
         `xi1`, /* red cb transition width; ignored, red cr transition width used */
         `xu2`, /* red bright index */
         `xu2`  /* red dark index */
      },
   },
   /* Wavelet Denoise */
   {

/******************************************************************************/
// Feature name: Wavelet denoise
// Applicable chipset:  N/A.
// 3A version: N/A.
// Applicable operation mode:  Snapshot.
//
// Variable name: trigger_value.
// Gain or lux index value for each of the 6 profiles.
// Default value: 1.
// Data range: >=1. Value for the 6 patches are in incrementing order.
//
// Variable name: referenceNoiseProfileData.
// Noise profile (std) of an gray patch. There a total of 6 gray scale levels corresponding to 6 sets of profiles.
// From bright to dark patches.
// Each set of profile has 24 values. The order is:
// y 1st layer HL, y 2nd layer HL, y 3rd layer HL, y 4th layer HL, y 1st layer HH, y 2nd layer HH, y 3rd layer HH, y 4th layer HH,
// Cb 1st layer HL, Cb 2nd layer HL, Cb 3rd layer HL, Cb 4th layer HL, Cb 1st layer HH, Cb 2nd layer HH, Cb 3rd layer HH, Cb 4th layer HH,
// Cr 1st layer HL, Cr 2nd layer HL, Cr 3rd layer HL, Cr 4th layer HL, Cr 1st layer HH, Cr 2nd layer HH, Cr 3rd layer HH, Crb 4th layer HH
// VFE 4 or later chip sets have HW version wavelet, all HL noise profiles are not used.
// Default value: 0.
// Data range: 0-255.
//
// Variable name: denoise_scale.
// Denoise level.
// Default value: 3.
// Data range: 1-7.99
// Effect: Increase noise_scale to denoise more.
//
// Variable name: denoise_edge_softness.
// Edge softness level.
// Default value: 3.
// Data range: 1-15.99
// Effect: Increase denoise_edge_softness to make the edges softer and denoise more.
//
// Variable name: denoise_weight.
// How much of the details are kept with the noise.
// Default value: 0.3
// Data range: 0-1.
// Effect: Decrease denoise_weight to remove details and denoise more.
//
// Variable name: sw_denoise_edge_threshold.
// Edge threshold for the 4th level LL band.
// Default value: 204.
// Data range: 0-1024.
// Effect: Increase sw_denoise_edge_threshold to denoise more for an approximately 16x16 size noise.
/******************************************************************************/

      /* Wavelet Noise SW 420 */
      {

/******************************************************************************/
// Variable name: wavelet_enable_index.
// lux_index threshold above which the wavelet denoise is applied.
// Applicable chipset:  N/A.
// 3A version: N/A
// Applicable operation mode: Snapshot.
// default Value: 1.
// Data Range: 1 to max_exp_index.
// Effect: Larger value results in pictures less likely to undergo wavelet denoise.
/******************************************************************************/

         `xu4`, /* Enable Index */
         `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */

/******************************************************************************/
// Feature name: Wavelet denoise
// Variable name: referencePatchAverageValue.
// Lux index or gain for the image.
// Applicable chipset:  N/A.
// 3A version: N/A.
// Applicable operation mode:  Snapshot.
// Default value: 0.
// Data range: 0-255.
//
// Variable name: referenceNoiseProfileData.
// Noise profile(std) of an gray patch.
// Applicable chipset:  N/A.
// 3A version: N/A.
// Applicable operation mode:  snapshot.
// Default value: 0.
// Data range: 0-255.
/******************************************************************************/

         /* Reference Noise */
         {
            /* Noise Profile 1 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 2 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 3 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 4 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 5 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 6 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
         },
      },
      /* Wavelet Noise SW 422 */
      {

/******************************************************************************/
// Variable name: wavelet_enable_index.
// lux_index threshold above which the wavelet denoise is applied.
// Applicable chipset:  N/A.
// 3A version: N/A
// Applicable operation mode: Snapshot.
// default Value: 1.
// Data Range: 1 to max_exp_index.
// Effect: Larger value results in pictures less likely to undergo wavelet denoise.
/******************************************************************************/

         `xu4`, /* Enable Index */
         `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */

/******************************************************************************/
// Feature name: Wavelet denoise
// Variable name: referencePatchAverageValue.
// Lux index or gain for the image.
// Applicable chipset:  N/A.
// 3A version: N/A.
// Applicable operation mode:  Snapshot.
// Default value: 0.
// Data range: 0-255.
//
// Variable name: referenceNoiseProfileData.
// Noise profile(std) of an gray patch.
// Applicable chipset:  N/A.
// 3A version: N/A.
// Applicable operation mode:  snapshot.
// Default value: 0.
// Data range: 0-255.
/******************************************************************************/

         /* Reference Noise */
         {
            /* Noise Profile 1 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 2 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 3 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 4 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 5 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 6 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
         },
      },
      /* Wavelet Noise HW 420 */
      {

/******************************************************************************/
// Variable name: wavelet_enable_index.
// lux_index threshold above which the wavelet denoise is applied.
// Applicable chipset:  N/A.
// 3A version: N/A
// Applicable operation mode: Snapshot.
// default Value: 1.
// Data Range: 1 to max_exp_index.
// Effect: Larger value results in pictures less likely to undergo wavelet denoise.
/******************************************************************************/

         `xu4`, /* Enable Index */
         `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */

/******************************************************************************/
// Feature name: Wavelet denoise
// Variable name: referencePatchAverageValue.
// Lux index or gain for the image.
// Applicable chipset:  N/A.
// 3A version: N/A.
// Applicable operation mode:  Snapshot.
// Default value: 0.
// Data range: 0-255.
//
// Variable name: referenceNoiseProfileData.
// Noise profile(std) of an gray patch.
// Applicable chipset:  N/A.
// 3A version: N/A.
// Applicable operation mode:  snapshot.
// Default value: 0.
// Data range: 0-255.
/******************************************************************************/

         /* Reference Noise */
         {
            /* Noise Profile 1 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 2 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 3 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 4 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 5 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 6 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
         },
      },
      /* Wavelet Noise HW 422 */
      {

/******************************************************************************/
// Variable name: wavelet_enable_index.
// lux_index threshold above which the wavelet denoise is applied.
// Applicable chipset:  N/A.
// 3A version: N/A
// Applicable operation mode: Snapshot.
// default Value: 1.
// Data Range: 1 to max_exp_index.
// Effect: Larger value results in pictures less likely to undergo wavelet denoise.
/******************************************************************************/

         `xu4`, /* Enable Index */
         `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */

/******************************************************************************/
// Feature name: Wavelet denoise
// Variable name: referencePatchAverageValue.
// Lux index or gain for the image.
// Applicable chipset:  N/A.
// 3A version: N/A.
// Applicable operation mode:  Snapshot.
// Default value: 0.
// Data range: 0-255.
//
// Variable name: referenceNoiseProfileData.
// Noise profile(std) of an gray patch.
// Applicable chipset:  N/A.
// 3A version: N/A.
// Applicable operation mode:  snapshot.
// Default value: 0.
// Data range: 0-255.
/******************************************************************************/

         /* Reference Noise */
         {
            /* Noise Profile 1 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 2 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 3 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 4 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 5 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
            /* Noise Profile 6 */
            {
               `xf4`, /* Trigger Value */
               {
                  `xf4a8`,
                  `xf4a8`,
                  `xf4a8`
               },
               /* Denoise Scale Y */
               {
                  `xf4a4`
               },
               /* Denoise Scale Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Y */
               {
                  `xf4a4`
               },
               /* Denoise Edge Softness Chroma */
               {
                  `xf4a4`
               },
               /* Denoise Weight Y */
               {
                  `xf4a4`
               },
               /* Denoise Weight Chroma */
               {
                  `xf4a4`
               },
               `xu4`, /* SW Denosie Edge Threshold Y */
               `xu4`, /* SW Denosie Edge Threshold Chroma */
            },
         },
      },
   },
   /* Wavelet Temporal Noise */
   {
      `xu4`, /* Enable Index */
      `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */
      /* Reference Noise */
      {

/******************************************************************************/
// Feature name: Temporal denoise
// Variable name: temporal_denoise_scale_y, temporal_denoise_scale_chroma.
// Denoise level.
// Default value: 3.
// Data range: 1-7.99
// Effect: Increase temporal_denoise_scale to reduce flickering more with increase in ghosting
/******************************************************************************/

         /* Profile 1 */
         {
            `xf4`, /* Trigger Value */
            /* Noise Profile */
            {
               `xf4`, /* Y */
               `xf4`, /* cb */
               `xf4`, /* cr */
            },
            `xf4`, /* Denoise Scale Y */
            `xf4`, /* Denosie Scale Chroma */
         },
         /* Profile 2 */
         {
            `xf4`, /* Trigger Value */
            /* Noise Profile */
            {
               `xf4`, /* Y */
               `xf4`, /* cb */
               `xf4`, /* cr */
            },
            `xf4`, /* Denoise Scale Y */
            `xf4`, /* Denosie Scale Chroma */
         },
         /* Profile 3 */
         {
            `xf4`, /* Trigger Value */
            /* Noise Profile */
            {
               `xf4`, /* Y */
               `xf4`, /* cb */
               `xf4`, /* cr */
            },
            `xf4`, /* Denoise Scale Y */
            `xf4`, /* Denosie Scale Chroma */
         },
         /* Profile 4 */
         {
            `xf4`, /* Trigger Value */
            /* Noise Profile */
            {
               `xf4`, /* Y */
               `xf4`, /* cb */
               `xf4`, /* cr */
            },
            `xf4`, /* Denoise Scale Y */
            `xf4`, /* Denosie Scale Chroma */
         },
         /* Profile 5 */
         {
            `xf4`, /* Trigger Value */
            /* Noise Profile */
            {
               `xf4`, /* Y */
               `xf4`, /* cb */
               `xf4`, /* cr */
            },
            `xf4`, /* Denoise Scale Y */
            `xf4`, /* Denosie Scale Chroma */
         },
         /* Profile 6 */
         {
            `xf4`, /* Trigger Value */
            /* Noise Profile */
            {
               `xf4`, /* Y */
               `xf4`, /* cb */
               `xf4`, /* cr */
            },
            `xf4`, /* Denoise Scale Y */
            `xf4`, /* Denosie Scale Chroma */
         },
      },
      `xu4`, /* Algorithm Select, 0 power function, 1 Gaussian, 2 local linear minimum mean-squared error */
   },
   /* Skin Color Enhancement */
   {
      `xf4`, /* Skin Color Enhancement Enable */
      `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */

/******************************************************************************/
// Feature name : SCE(skin color enhancement) lowlight trigger points for
// preview and snapashot
/******************************************************************************/

      /* Lowlight Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },
      /* A CCT Trigger */
      {
         `xu4`, /* Start */
         `xu4`, /* End */
      },
      /* D65 CCT Trigger */
      {
         `xu4`, /* Start */
         `xu4`, /* End */
      },

/******************************************************************************/
// Feature name : SCE(skin color enhancement)
// variable name: cr_cb_triangle
// Three (Cr,Cb) points form a triangle.
// applicale chipset(s): 7x30, 8660, 867x
// applicable operation mode: preview and snapshot
// default value
// triangle 1: (40,-30), (17,-3), (10,-20)
// triangle 2: (40,-30), (70,-25), (17,-3)
// triangle 3: (40,-30), (65,-55), (70,-25)
// triangle 4: (40,-30), (45,-90), (65,-55)
// triangle 5: (40,-30), (10,-20), (45,-90)
// data range: (-128, 127) for each color channel
// constraints: triangles should not overlap each other
//              points should be in counter-clockwise order
// effect: change color from starting triangular area to target triangular area
/******************************************************************************/

      /* TL84 Origin Triangles */
      {
         /* SCE Origin Triangle 1 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Origin Triangle 2 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Origin Triangle 3 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Origin Triangle 4 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Origin Triangle 5 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
      },
      /* TL84 Destination Triangles */
      {
         /* SCE Destination Triangle 1 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Destination Triangle 2 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Destination Triangle 3 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Destination Triangle 4 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Destination Triangle 5 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
      },
      /* TL84 Shift Vector */
      {
         `xf4`, /* cr */
         `xf4`, /* cb */
      },

/******************************************************************************/
// Feature name : SCE(skin color enhancement)
// variable name: sce_affine_transform_2d
// 2x3 transformation matrix
// applicale chipset(s): 7x30, 8660, 867x
// applicable operation mode: preview and snapshot
// default: a=1, b=0, c=0, d=0,e=1, f=0.
// data range: computed according to start and target triangles
// constraints:
//  cr' = [ a   b    c] cr
//  cb' = [ d   e    f] cb
//   1  = [ 0   0    1] 1
// effect: remap a color to a different color
/******************************************************************************/

      /* Outside Region Mapping */
      {
         `xf4`, /* a */
         `xf4`, /* b */
         `xf4`, /* c */
         `xf4`, /* d */
         `xf4`, /* e */
         `xf4`, /* f */
      },
      /* A Origin Triangles */
      {
         /* SCE Origin Triangle 1 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Origin Triangle 2 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Origin Triangle 3 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Origin Triangle 4 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Origin Triangle 5 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
      },
      /* A Destination Triangles */
      {
         /* SCE Destination Triangle 1 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Destination Triangle 2 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Destination Triangle 3 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Destination Triangle 4 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Destination Triangle 5 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
      },
      /* A Shift Vector */
      {
         `xf4`, /* cr */
         `xf4`, /* cb */
      },
      /* D65 Origin Triangles */
      {
         /* SCE Origin Triangle 1 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Origin Triangle 2 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Origin Triangle 3 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Origin Triangle 4 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Origin Triangle 5 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
      },
      /* D65 Destination Triangles */
      {
         /* SCE Destination Triangle 1 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Destination Triangle 2 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Destination Triangle 3 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Destination Triangle 4 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
         /* SCE Destination Triangle 5 */
         {
            {`xi4a2`},
            {`xi4a2`},
            {`xi4a2`}
         },
      },
      /* D65 Shift Vector */
      {
         `xf4`, /* cr */
         `xf4`, /* cb */
      },
   },
   /* Statistics Configuration */
   {
      /* AWB Stats */
      {

/*********************************************************************/
// Feature name : AWB Low Light Bounding Box
// Bounding box to select near gray pixels for AWB under low light.
// This setting is used  when exposure_index reaches max
// exposure_index provided in exposure table in Chromatix header.
/*********************************************************************/

         /* Low-Light AWB Stats */
         {
            `xu1`, /* YMin */
            `xu1`, /* YMax */
            /* Slope of neutral region and line number */
            `xi1`,
            `xi1`,
            `xi1`,
            `xi1`,
            /* Cb intercept of neutral region and line number */
            `xi2`,
            `xi2`,
            `xi2`,
            `xi2`
         },

/*********************************************************************/
// Feature name : AWB Bounding Box
// Bounding box to select near gray pixels for AWB under normal and bright light.
// This setting is used  when exposure_index is less than max
// exposure_index provided in exposure table in Chromatix header.
/*********************************************************************/

         /* Normal AWB Stats */
         {
            `xu1`, /* YMin */
            `xu1`, /* YMax */
            /* Slope of neutral region and line number */
            `xi1`,
            `xi1`,
            `xi1`,
            `xi1`,
            /* Cb intercept of neutral region and line number */
            `xi2`,
            `xi2`,
            `xi2`,
            `xi2`
         },

/*********************************************************************/
// Feature name : AWB Bright Best Shot Bounding Box
// Bounding box to select near gray pixels for AWB under bright light for
// the following best shot mode only: landscape, beach, snow. Under non best
// shot mode, this setting is not used.
//
/*********************************************************************/

         /* Outdoor AWB Stats */
         {
            `xu1`, /* YMin */
            `xu1`, /* YMax */
            /* Slope of neutral region and line number */
            `xi1`,
            `xi1`,
            `xi1`,
            `xi1`,
            /* Cb intercept of neutral region and line number */
            `xi2`,
            `xi2`,
            `xi2`,
            `xi2`
         },
      },
      /* Auto Flicker Detection (8k) */
      {

/******************************************************************************/
// Feature name : Auto flicker detection config (8k)
//
// chromatix_rscs_stat_config_type.row_sum_enable
// default value: 1
// data range: 0 or 1, 0 means disable, 1 means enable.
// constraints: N/A
// effect: enabled or disable AFD STATs collection
//
// chromatix_rscs_stat_config_type.row_sum_hor_Loffset_ratio
// Row sum window left offset/imageWidth ratio in horizontal direction
// default value: 0.0
// data range: 0.0 to 0.9
// constraints:
// effect: larger value will have less pixels on the left side contributed to STATs
//
// chromatix_rscs_stat_config_type.row_sum_ver_Toffset_ratio
// Row sum window top offset/imageWidth ratio in verticle direction
// default value: 0.0
// data range: 0.0 to 0.9
// constraints:
// effect: larger value will have less pixels from the top of image contributed to STATs
//
// chromatix_rscs_stat_config_type.row_sum_hor_Roffset_ratio
// Row sum window right offset/imageWidth ratio in horizontal direction
// default value: 0.0
// data range: 0.0 to 0.9
// constraints:
// effect: larger value will have less pixels on the right side contributed to STATs
//
// chromatix_rscs_stat_config_type.row_sum_ver_Boffset_ratio
// Row sum window bottom offset/imageWidth ratio in verticle direction
// default value: 0.0
// data range: 0.0 to 0.9
// constraints:
// effect: larger value will have less pixels from the bottom of image contributed to STATs
//
// chromatix_rscs_stat_config_type.row_sum_V_subsample_ratio
// Row sum vertical subsample ratio
// default value: 1
// data range: 1,2,3,4
// constraints: integer
// effect: larger value will have less STAT data
//
// chromatix_rscs_stat_config_type.col_sum_enable
// default value: 0
// data range: 0 or 1, 0 means disable, 1 means enable.
// constraints: N/A
// effect: enabled or disable column sum STATs collection
//
// chromatix_rscs_stat_config_type.col_sum_hor_Loffset_ratio
// Col sum window left offset/imageWidth ratio in horizontal direction
// default value: 0.0
// data range: 0.0 to 0.9
// constraints:
// effect: larger value will have less pixels on the left side contributed to STATs
//
// chromatix_rscs_stat_config_type.col_sum_ver_Toffset_ratio
// Col sum window top offset/imageHeight ratio in verticle direction
// default value: 0.0
// data range: 0.0 to 0.9
// constraints:
// effect: larger value will have less pixels from the top of image contributed to STATs
//
// chromatix_rscs_stat_config_type.col_sum_hor_Roffset_ratio
// Col sum window right offset/imageWidth ratio in horizontal direction
// default value: 0.0
// data range: 0.0 to 0.9
// constraints:
// effect: larger value will have less pixels on the left side contributed to STATs
//
// chromatix_rscs_stat_config_type.col_sum_ver_Boffset_ratio
// Col sum window bottom offset/imageHeight ratio in verticle direction
// default value: 0.0
// data range: 0.0 to 0.9
// constraints:
// effect: larger value will have less pixels from the top of image contributed to STATs
//
// chromatix_rscs_stat_config_type.col_sum_H_subsample_ratio
// Col sum horizontal subsample ratio
// default value: 2
// data range: 2,3,4
// constraints: integer
// effect: larger value will have less STAT data
/******************************************************************************/
`xa`
         `xu4`, /* Row Sum Enable */
         `xf4`, /* Row Sum Hor Loffset Ratio */
         `xf4`, /* Row Sum Ver Toffset Ratio */
         `xf4`, /* Row Sum Hor Roffset Ratio */
         `xf4`, /* Row Sum Ver Loffset Batio */
         `xu1+3`, /* Row Sum V Subsample Ratio */
         `xu4`, /* Col Sum Enable */
         `xf4`, /* Col Sum Hor Loffset Ratio */
         `xf4`, /* Col Sum Ver Toffset Ratio */
         `xf4`, /* Col Sum Hor Roffset Ratio */
         `xf4`, /* Col Sum Ver Loffset Batio */
         `xu1+3`, /* Col Sum H Subsample Ratio */
      },
      /* Bayer Histogram Config */
      {

/*********************************************************************/
// Feature name :  Bayer Histogram Statistics
// This group of parameters defines the coordinates of single Bayer Histogram window.
// Applicable chipset: all.
// Applicable operation mode:  For VF , snapshot and video.
// Supported 3A version:
//
// Variable name: HorizontalOffsetRatio.
// Horizontal location of first pixel in terms of the ratio to the whole frame size.
// For example, image width is 1000, we want to use the middle 500
// as BH window. Horizontal offset ratio is 250/1000=0.25.
// Data range: 0.0  0.5
// Default value:  0.0
// Constraints: horizontalOffsetRatio + horizontalWindowRatio <= 1.0
//
// Variable name: VerticalOffsetRatio.
// Similar to Horizontal Offset Ratio, but this is in the vertical direction.
// Data range: 0.0  0.5
// Default value:  0.0
// Constraints: verticalOffsetRatio + verticalWindowRatio   <= 1.0
//
// Variable name: HorizontalWindowRatio.
// BH window horizontal size in terms of ratio to the whole image. For the
// same example above, Horizontal Window Ratio is 500/1000=0.5.
// Data range: 0.0  1.0
// Default value:  1.0
// Constraints: horizontalOffsetRatio + horizontalWindowRatio <= 1.0
//
// Variable name: VerticalWindowRatio.
// BH window veritical size in terms of ratio to the whole image. For the
// same example above, Vertical Window Ratio is 500/1000=0.5.
// Data range: 0.0  1.0
// Default value:  1.0
// Constraints: verticalOffsetRatio + verticalWindowRatio   <= 1.0
/*********************************************************************/

         `xf4`, /* Horizontal Offset Ratio */
         `xf4`, /* Vertical Offset Ratio */
         `xf4`, /* Horizontal Window Ratio */
         `xf4`, /* Vertical Window Ratio */
      },
      /* Bayer Grid Config */
      {

/*********************************************************************/
// Feature name :  Bayer Grid Statistics
// This group of parameters defines the coordinates of single Bayer Grid window.
// Applicable chipset: all.
// Applicable operation mode:  For VF , snapshot and video.
// supported 3A version:
//
// Variable name: saturation_thresh_R.
// When collecting Bayer Grid statistics, only pixels with all of its channel values
// same or higher than each channels threshold will be counted. This value is the
// threshold for R channel
// Data range: 0  255.
// Default value: 239.
//
// Variable name: saturation_thresh_Gr.
// Similar to saturation_thresh_R, this value is the threshold for Gr channel
// Data range: 0  255
// Default value: 239
//
// Variable name: saturation_thresh_Gb.
// Similar to saturation_thresh_R, this value is the threshold for Gb channel
// Data range: 0  255.
// Default value: 239.
//
// Variable name: saturation_thresh_B.
// Similar to saturation_thresh_R, this value is the threshold for B channel
// Data range: 0  255.
// Default value: 239.
//
// Variable name: HorizontalOffsetRatio.
// Horizontal location of first pixel in terms of the ratio to the whole frame size.
// For example, image width is 1000, we want to use the middle 500 pixels
// as BG window. Horizontal offset ratio is 250/1000=0.25.
// Data range: 0.0  0.5.
// default: 0.015
// Constraints: horizontalOffsetRatio + horizontalWindowRatio <= 1.0
//
// Variable name: VerticalOffsetRatio.
// Similar to Horizontal Offset Ratio, but this is in the vertical direction.
// Data range: 0.0  0.5.
// default: 0.015
// Constraints: verticalOffsetRatio + verticalWindowRatio   <= 1.0
//
// Variable name: HorizontalWindowRatio.
// BG window horizontal size in terms of ratio to the whole image. For the
// same example above, Horizontal Window Ratio is 500/1000=0.5.
// Data range: 0.0  1.0.
// Default value: 0.97
// Constraints: horizontalOffsetRatio + horizontalWindowRatio <= 1.0
//
// Variable name: VerticalWindowRatio.
// BG window veritical size in terms of ratio to the whole image. For the
// same example above, Vertical Window Ratio is 500/1000=0.5.
// Data range: 0.0  1.0.
// Default value: 0.97
// Constraints: verticalOffsetRatio + verticalWindowRatio   <= 1.0
//
// Variable name: num_H_regions.
// Number of Bayer Grid regions in horizontal direction
// range: 1  72.
// Default value: 64.
//
// Variable name: num_V_regions.
// Number of Bayer Grid regions in vertical direction
// Data range: 1  48.
// Default value: 48.
/*********************************************************************/

         `xu1`, /* Saturation Thresh R */
         `xu1`, /* Saturation Thresh GR */
         `xu1`, /* Saturation Thresh GB */
         `xu1`, /* Saturation Thresh B */
         `xf4`, /* Horizontal Offset Ratio */
         `xf4`, /* Vertical Offset Ratio */
         `xf4`, /* Horizontal Window Ratio */
         `xf4`, /* Vertical Window Ratio */
         `xu2`, /* Num H Regions */
         `xu2`, /* Num V Regions */
      },
      /* Bayer Exp Window */
      {
         `xu1`, /* Saturation Thresh R */
         `xu1`, /* Saturation Thresh GR */
         `xu1`, /* Saturation Thresh GB */
         `xu1`, /* Saturation Thresh B */
         `xf4`, /* Horizontal Offset Ratio */
         `xf4`, /* Vertical Offset Ratio */
         `xf4`, /* Horizontal Window Ratio */
         `xf4`, /* Vertical Window Ratio */
         `xu2`, /* Num H Regions */
         `xu2`, /* Num V Regions */
      },
   },
   /* Skintone Detection */
   {

/******************************************************************************/
// Feature name : Skin Tone Detection
// Applicale chipset(s): MSM8xxx chips.
// Applicable operation mode: For VF and snapshot.
//
// skintone_Hmin
// The negative of the minimum value of the H range.
// Default value:  1.5.
// Data range: 1.0 to 3.0.
// Constraints: skintone_Hmin > skintone_Hmax (because the original data is negative).
// Effect: Larger values will result in smaller skin tone range.
//
// skintone_Hmax
// The negative of the maximum value of the H range.
// Default value:  0.5.
// Data range: 0.0 to 1.0.
// Constraints: skintone_Hmin > skintone_Hmax (because the original data is negative)
// Effect: Larger values will result in wider skin tone range.
//
// skintone_Ymin
// The minimum value of the Y range.
// Applicable operation mode:  For VF and snapshot.
// Default value:  0.1.
// Data range: 0.0 to 0.3.
// Constraints: skintone_Ymax > skintone_Ymin.
// Effect: Smaller values will result in wider skin tone range, including more dark areas.
//
// skintone_Ymax
// The maximum value of the Y range.
// Default value:  0.9.
// Data range: 0.7 to 1.0.
// Constraints: skintone_Ymax > skintone_Ymin.
// Effect: Larger values will result in wider skin tone range, including more bright areas.
//
// skintone_S_HY_min
// The minimum value of S on Ymax level.
// Default value:  0.05.
// Data range: 0.0 to 0.4.
// Constraints: skintone_S_HY_max > skintone_S_HY_min.
// Effect: Smaller values will result in wider skin tone range.
//
// skintone_S_HY_max
// The maximum value of S on Ymax level.
// Default value:  0.25.
// Data range: 0.1 to 0.5.
// Constraints: skintone_S_HY_max > skintone_S_HY_min.
// Effect: Larger values will result in wider skin tone range.
//
// skintone_S_LY_min
// The minimum value of S on Ymin level.
// Default value:  0.25.
// Data range: 0.0 to 0.5.
// Constraints: skintone_S_LY_max > skintone_S_LY_min.
// Effect: smaller values will result in wider skin tone range.
//
// skintone_S_LY_max
// The maximum value of S on Ymin level.
// Default value:  0.6.
// Data range: 0.2 to 1.0.
// Constraints: skintone_S_LY_max > skintone_S_LY_min.
// Effect: Larger values will result in wider skin tone range.
//
// skintone_percentage
// Percentage of skin color pixels to activate skin color map.
// Default value:  50.
// Data range: 0 to 100.
// Effect: The larger the value, the harder to activate the skin color map.
/******************************************************************************/

      `xf4`, /* H Min */
      `xf4`, /* H Max */
      `xf4`, /* Y Min */
      `xf4`, /* Y Max */
      `xf4`, /* S HY Min */
      `xf4`, /* S HY Max */
      `xf4`, /* S LY Min */
      `xf4`, /* S LY Max */
      `xu1+3`, /* Percentage */
   },
},
/* Manual Whitebalance */
{

/*********************************************************************/
// Feature name :
// Manual white balance gains for both snapshot and viewfinder.
/*********************************************************************/

   /* TL84 Whitebalance - RGB */
   {`xf4a3`},
   /* D50 Whitebalance - RGB */
   {`xf4a3`},
   /* A Whitebalance - RGB */
   {`xf4a3`},
   /* D65 Whitebalance - RGB */
   {`xf4a3`},
   /* Strobe Flash Whitebalance - RGB */
   {`xf4a3`},
   /* LED Flash Whitebalance - RGB */
   {`xf4a3`},
},
/* Auto Whitebalance */
{
   `xu4`, /* Software Type */

/*********************************************************************/
// Feature name :
//
// R/G ratio, B/G ratio: AWB referecne points used for auto WB calculation.
//
//Red Gain Adjust,Blue Gain Adjust: Additional gain applied for snapshot only.
/*********************************************************************/

   /* AWB Reference Points w/HW */
   {
      /* D65 AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* Shade AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* A AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* TL84 AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* CoolWhite AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* Horizon AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* D50 AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* Cust. Fluor. AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* Noon AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* Custom Daylight AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* Custom A AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* U30 AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
   },
   /* LED Gain Adjust */
   {
      `xf4`, /* Red */
      `xf4`, /* Blue */
   },
   /* Strobe Gain Adjust */
   {
      `xf4`, /* Red */
      `xf4`, /* Blue */
   },
   /* AWB Gain Adjust */
   {
      /* D65 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* D75 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* A */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* TL84 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* CW */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Horizon */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* D50 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Cust Flo */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Noon */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Daylight */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Cust A */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* U30 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
   },
   /* AWB Lowlight Gain Adjust */
   {
      /* D65 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* D75 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* A */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* TL84 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* CW */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Horizon */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* D50 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Cust Flo */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Noon */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Daylight */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Cust A */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* U30 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
   },

/*********************************************************************/
// Comment:
// Indoor and outdoor index are the parameters used in AWB algorithm in
// a variety of heuristics. We do not recommend the user change these values.
/*********************************************************************/

   `xu4`, /* Indoor Index */
   `xu4`, /* Outdoor Index */

/*********************************************************************/
// Feature name :
// Blue gain adj ratio is used for Snow and Beach best shot modes only. This factor
// is applied on top of the blue WB gain determined by AWB algorithm.
// Range: 0.7 to 1.5.
/*********************************************************************/

   `xf4`, /* Snow Blue Gain Adj Ratio */
   `xf4`, /* Beach Blue Gain Adj Ratio */

/*********************************************************************/
// Feature name :
// The following group of parameters are used by AWB algorithm. We do not
// recommend the user modify them.
/*********************************************************************/

   `xu4`, /* Outlier Distance */
   `xu4`, /* Green Zone Offset RG */
   `xu4`, /* Green Zone Offset BG */
   `xu1+3`, /* Num Frames to skip after changing VFE */

/*******************************************************************************/
// variable name: awb_extreme_RG_ratio_threshold
// boundary to collect stat in R/G direction
// applicale chipset(s): VFE 3.1 and higher
// applicable operation mode: preview, camcorder, snapshot
// default value (calculated-NA): 1.1 x R/G value of blue patch on MCC (#15) under Horizon
// data range: 0.0 to 4.0
// constraints: 0.0 to 4.0
// effect: higher value allows less pixels to be collected.
/******************************************************************************/

   `xf4`, /* AWB Extreme RG Ratio Treshold */

/*******************************************************************************/
// variable name: awb_extreme_BG_ratio_threshold
// boundary to collect stat in B/G direction
// applicale chipset(s): VFE 3.1 and higher
// applicable operation mode: preview, camcorder, snapshot
// default value (calculated-NA): 1.1 x B/G value of blue patch on MCC (#13) under TL84
// data range: 0.0 to 4.0
// constraints: 0.0 to 4.0
// effect: higher value allows less pixels to be collected.
/******************************************************************************/

   `xf4`, /* AWB Extreme BG Ratio Treshold */
   /* More AWB Parameters */
   `xu2`, /* Compact Cluster R2 */
   `xu2`, /* Compact Cluster To Ref Point R2 */
   `xu1`, /* A Cluster Threshold */
   `xu1`, /* F Cluster Threshold */
   `xu1`, /* Day Cluster Threshold */
   `xu1`, /* Outdoor Green Threshold */
   `xu1`, /* Outdoor Green Threshold Bright F */
   `xu1`, /* Outdoor Green Threshold Dark F */
   `xu1`, /* Day Cluster Threshold For F */
   `xu1`, /* Whitebalance Allow FLine */
   `xu1`, /* Outdoor Valid Sample Count Threshold */
   `xu1`, /* Outdoor Green Upper Threshold */
   `xu2`, /* R2 Threshold */
   `xu1`, /* Outdoor Green Threshold Bright A */
   `xu1`, /* Outdoor Green Threshold Dark A */
   `xu1+1`, /* Day Cluster Threshold For A */

/*********************************************************************/
// Feature name :
// The final WB gain applied to the system is mandated to be between min
// and max WB values.  We do not recommend the user change the values.
/*********************************************************************/

   /* AWB Min Gains - RGB */
   {`xf4a3`},
   /* AWB Max Gains - RGB */
   {`xf4a3`},

/*********************************************************************/
// Feature name :
// The following group of parameters are used by AWB algorithm. We do not
// recommend the user modify them.
/*********************************************************************/

   { `xf4a2` }, /* AWB Sample Influence, Outdoor/Indoor */
   /* AWB Weight Vector */
   {
      {`xu4a3`}, /* AWB Weight Vector D65 */
      {`xu4a3`}, /* AWB Weight Vector D75 */
      {`xu4a3`}, /* AWB Weight Vector A */
      {`xu4a3`}, /* AWB Weight Vector Warm F */
      {`xu4a3`}, /* AWB Weight Vector Cool F */
      {`xu4a3`}, /* AWB Weight Vector Horizon */
      {`xu4a3`}, /* AWB Weight Vector D50 */
      {`xu4a3`}, /* AWB Weight Vector Cust F */
      {`xu4a3`}, /* AWB Weight Vector Daylight Noon */
      {`xu4a3`}, /* AWB Weight Vector Custom Daylight */
      {`xu4a3`}, /* AWB Weight Vector Custom A */
      {`xu4a3`}, /* AWB Weight Vector U30 */
      {`xu4a3`}, /* AWB Weight Vector DayLine 1 */
      {`xu4a3`}, /* AWB Weight Vector DayLine 2 */
      {`xu4a3`}, /* AWB Weight Vector FLine */
      {`xu4a3`}, /* AWB Weight Vector ALine 1 */
      {`xu4a3`}, /* AWB Weight Vector ALine 2 */
   },
   `xu4`, /* AWB White World Y Min Ratio */

/*********************************************************************/
// Feature name :
// AWB aggresiveness
// 0 low aggressive
// 1 medium aggressive
// 2 high aggressive
/*********************************************************************/

   `xf4`, /* AWB Aggressiveness */
   `xu4`, /* AWB Self-Calibrate */

/******************************************************************************/
// Feature name : AWB self calibration
// variable name:
// Adjust amount of adjustment allowed for AWB self calibration
// applicale chipset(s): all MSM
// applicable operation mode: preview
// default value: high=1.15
// default value: low=0.9
// data range: high (1.0, 1.2), low (0.8, 1.0)
// constraints:
// effect: larger high = larger adjustment, smaller low = larger adjustment
/******************************************************************************/

   `xf4`, /* AWB Self-Calibrate Adjust Ratio High */
   `xf4`, /* AWB Self-Calibrate Adjust Ratio Low */

/******************************************************************************/
// Feature name : AWB
// applicale chipset(s): all MSM
// applicable operation mode: preview
//
// variable name: awb_enable_lock_heuristics_1
// Enable lock heuristics #1
// default value: 1 (enable)
// data range: 0 or 1
// constraints: 0 or 1
// effect: 1 to enable lock/unlock heuristics #1.
// Prevents outdoor decision to be switched into indoor.
//
// variable name: awb_enable_lock_heuristics_2
// Enable lock heuristics #2
// default value: 1 (enable)
// data range: 0 or 1
// constraints: 0 or 1
// effect: 1 to enable lock/unlock heuristics #2.
// Prevents fluorescent light to be switched to outdoor.
//
// variable name: awb_enable_lock_heuristics_3
// Enable lock heuristics #3
// default value: 1 (enable)
// data range: 0 or 1
// constraints: 0 or 1
// effect: 1 to enable lock/unlock heuristics #3.
// Prevents fluorescent light to be switched to incandescent.
/******************************************************************************/

   `xu1`, /* AWB Enable Lock Heuristics 1 */
   `xu1`, /* AWB Enable Lock Heuristics 2 */
   `xu1`, /* AWB Enable Lock Heuristics 3 */
   `xu1`, /* Indoor Daylight Lock Enable */

/******************************************************************************/
// Feature name : AWB
// variable name: awb_enable_white_world
// Enable adaptive white world
// applicale chipset(s): all MSM
// applicable operation mode: preview
// default value: 1 (enable)
// data range: 0 or 1
// constraints: 0 or 1
// effect: 1 to enable adaptive white world
/******************************************************************************/

   `xu1+3`, /* AWB Enable White World */
   /* Purple Prevent */
   {

/******************************************************************************/
// Feature name : AWB Extended
// applicable chipset:  all VFEs.
// applicable operation mode: View finder and snapshot.
//
// variable name: AWB_purple_prevent_enable
// Enables the feature.
// default value: 1
// data range: 0 and 1
// constraints: None
//
// variable name: control_purple_prevent
// Control with gain or lux_index
// default Value: 0
// Data Range: 0 or 1.
// constraints: None
// effect: use gain or lux_index for control purple sky prevention
//
// variable name: purple_prevent_trigger
// Control the purple sky prevention adjustment trigger
// default Value: between  outdoor index and outdoor index
// Data Range: integers 0 to a few hundreds.
// constraints: only for bright outdoor
// effect: smaller index values make the purple sky prevention harder to take effect. (has to be very bright)
//
// variable name: purple_sky_prevention_bg_threshold
// Control the purple sky prevention adjustment
// default Value: BG ratio of D50
// Data Range: 0 to 2
// constraints: around D50
// effect: smaller index values make the adjustment larger.
/******************************************************************************/

      `xu4`, /* Enable */
      `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */
      /* Trigger Point */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },
      `xf4`, /* Sky Prevention BG Thresh */
   },
   `xu1`, /* AWB Ymin Low Threshold */
   `xu1+2`, /* AWB Ymin High Threshold */

/******************************************************************************/
// Feature name : AWB golden module calibration data
//               for module-by-module variation
// applicale chipset(s): all MSM
// applicable operation mode: camera & camcorder preview/recording/snapshot
//
// variable name: AWB_golden_module_R_Gr_ratio
// Not tunable. Read it out from modules EEPROM and convert into floating point
// default value: none. The value read out from modules EEPROM
// data range: 0 and 4
// constraints: none
// effect: not tunable

// variable name: AWB_golden_module_Gb_Gr_ratio
// Not tunable. Read it out from modules EEPROM and convert into floating point
// default value: none. The value read out from modules EEPROM
// data range: 0.8 and 1.2
// constraints: none
// effect: not tunable
//
// variable name: AWB_golden_module_B_Gr_ratio
// Not tunable. Read it out from modules EEPROM and convert into floating point
// default value: none. The value read out from modules EEPROM
// data range: 0 and 4
// constraints: none
// effect: not tunable
/******************************************************************************/

   /* R/Gr */
   {
      `xf4`, /* Golden Module R/Gr ratio D65 */
      `xf4`, /* Golden Module R/Gr ratio D75 */
      `xf4`, /* Golden Module R/Gr ratio A */
      `xf4`, /* Golden Module R/Gr ratio TL84 */
      `xf4`, /* Golden Module R/Gr ratio CW */
      `xf4`, /* Golden Module R/Gr ratio H */
      `xf4`, /* Golden Module R/Gr ratio D50 */
      `xf4`, /* Golden Module R/Gr ratio Cust F */
      `xf4`, /* Golden Module R/Gr ratio Noon */
      `xf4`, /* Golden Module R/Gr ratio Cust Daylight */
      `xf4`, /* Golden Module R/Gr ratio Cust A */
      `xf4`, /* Golden Module R/Gr ratio U30 */
   },
   /* Gb/Gr */
   {
      `xf4`, /* Golden Module Gb/Gr ratio D65 */
      `xf4`, /* Golden Module Gb/Gr ratio D75 */
      `xf4`, /* Golden Module Gb/Gr ratio A */
      `xf4`, /* Golden Module Gb/Gr ratio TL84 */
      `xf4`, /* Golden Module Gb/Gr ratio CW */
      `xf4`, /* Golden Module Gb/Gr ratio H */
      `xf4`, /* Golden Module Gb/Gr ratio D50 */
      `xf4`, /* Golden Module Gb/Gr ratio Cust F */
      `xf4`, /* Golden Module Gb/Gr ratio Noon */
      `xf4`, /* Golden Module Gb/Gr ratio Cust Daylight */
      `xf4`, /* Golden Module Gb/Gr ratio Cust A */
      `xf4`, /* Golden Module Gb/Gr ratio U30 */
   },
   /* B/Gr */
   {
      `xf4`, /* Golden Module B/Gr ratio D65 */
      `xf4`, /* Golden Module B/Gr ratio D75 */
      `xf4`, /* Golden Module B/Gr ratio A */
      `xf4`, /* Golden Module B/Gr ratio TL84 */
      `xf4`, /* Golden Module B/Gr ratio CW */
      `xf4`, /* Golden Module B/Gr ratio H */
      `xf4`, /* Golden Module B/Gr ratio D50 */
      `xf4`, /* Golden Module B/Gr ratio Cust F */
      `xf4`, /* Golden Module B/Gr ratio Noon */
      `xf4`, /* Golden Module B/Gr ratio Cust Daylight */
      `xf4`, /* Golden Module B/Gr ratio Cust A */
      `xf4`, /* Golden Module B/Gr ratio U30 */
   },
   `xu4`, /* Enable AWB Module Cal */
   /* AWB Motion Sensor */
   {

/******************************************************************************/
// Feature name : AWB_motion_sensor_type to aide AWB in determining a change in
//           scene.
// Applicable chipset: MSM7x30, QSD8x60, and newer chipsets.
// Applicable operation mode: Viewfinder and video.
//
// Variable name: awb_gyro_trigger.
// Used to control how scene change should be detected for AEC
// 3A version: 3.0.
// Default value: 0.0.
// Data range: -16000.0 to +16000.0.
// Constraints: None .
// Effect: The bigger the value is, the less sensitive AEC response to
//         gyro output value.
//
// Variable name: awb_accelerometer_trigger.
// Used to control how scene change should be detected for AEC.
// 3A version: 3.0.
// Default value: 0.0.
// Data range: -16000.0 to +16000.0.
// Constraints: None.
// Effect: The bigger the value is, the less sensitive AEC response to
//         accelerometer change.
//
// Variable name: awb_magnetometer_trigger.
// Used to control how scene change should be detected for AEC
// 3A version: 3.0.
// Default value: 0.0.
// Data range: 0.0 to 360.0.
// Constraints: None.
// Effect: The bigger the value is, the less sensitive AEC response to
//         magnetic field change.
//
// Variable name: awb_DIS_motion_vector_trigger.
// Used to control how scene change should be detected for AEC.
// 3A version: 3.0.
// Default value: 0.0.
// Data range: -16000.0 to +16000.0.
// Constraints: None.
// Effect: The bigger the value is, the less sensitive AEC response to
//         digital image stabilization movement/compensation value.
/******************************************************************************/

      `xf4`, /* Gyro Trigger */
      `xf4`, /* Accelerometer Trigger */
      `xf4`, /* Magnetometer Trigger */
      `xf4`, /* DIS Motion Vector Trigger */
   },
   `xf4`, /* LED/Strobe Adjustment Factor */
   `xu1`, /* Lowlight Toggle Enable */
   `xu1+2`, /* Interpolate Gain Adj Enable */
   /* Lowlight LUT */
   {
      `xu1+3`, /* Enable */
      {
         /* Entry 0 */
         {
            `xu4`, /* Lux Index */
            `xf4`, /* Green RG Offset Adj */
            `xf4`, /* Green BG Offset Adj */
            `xf4`, /* Outlier Dist Adj */
         },
         /* Entry 1 */
         {
            `xu4`, /* Lux Index */
            `xf4`, /* Green RG Offset Adj */
            `xf4`, /* Green BG Offset Adj */
            `xf4`, /* Outlier Dist Adj */
         },
         /* Entry 2 */
         {
            `xu4`, /* Lux Index */
            `xf4`, /* Green RG Offset Adj */
            `xf4`, /* Green BG Offset Adj */
            `xf4`, /* Outlier Dist Adj */
         },
         /* Entry 3 */
         {
            `xu4`, /* Lux Index */
            `xf4`, /* Green RG Offset Adj */
            `xf4`, /* Green BG Offset Adj */
            `xf4`, /* Outlier Dist Adj */
         },
         /* Entry 4 */
         {
            `xu4`, /* Lux Index */
            `xf4`, /* Green RG Offset Adj */
            `xf4`, /* Green BG Offset Adj */
            `xf4`, /* Outlier Dist Adj */
         },
         /* Entry 5 */
         {
            `xu4`, /* Lux Index */
            `xf4`, /* Green RG Offset Adj */
            `xf4`, /* Green BG Offset Adj */
            `xf4`, /* Outlier Dist Adj */
         },
      },
   },

/******************************************************************************/
// Feature name : Match LED Level
// Applicale chipset: MSM8x30 and later.
// Applicable operation mode:  For video and snapshot.
//
// This is the feature to match dual LED flash with the ambient lighting.
//
// Desription of variables in chromatix_match_LED_lighting_table
// structure.
//
// Variable names: table_size, CCT_control[table_size-1].
// The three values for the table entries:
// The color temperature
// The LED1 current configuration for LED controller IC
// The LED2 current configuration for LED controller IC
/******************************************************************************/

   /* Mix LED Table */
   {
      `xu2`, /* Table Size */
      {
         /* Entry 0 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 1 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 2 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 3 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 4 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 5 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 6 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 7 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 8 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 9 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 10 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 11 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 12 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 13 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 14 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 15 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
      },
   },
},
`xa`/* Bayer AWB Params */
{

/*****************************************************************/
// Feature name: Bayer AWB parameters.
// Applicable chipset:  VFE3.3 and higher.
// 3A version: 4.0 and higher.
// Applicable operation mode: preview and snapshot
// (except for preview aggressivenes and camcorder aggressiveness).
//
// Variable name: bright_green_percentage.
// Bright green percentage at outdoor index.
// Default value: 6.
// Data range: 0 to 100.
// Constraints: This is a pre-set threshold obtained by testing.
// Effect: Higher value extends the outdoor green range.
//
// Variable name: dark_green_percentage.
// Dark green percentage at indoor index.
// Default value: 12.
// Data range: 0 to 100.
// Constraints: This is a pre-set threshold obtained by testing.
// Effect: Indoor green range is extended or narrowed down.
//
// Variable names: dark_r_threshold, dark_g_threshold, dark_b_threshold.
// R(or G or B) stat ave below this value is rejected (8-bit domain).
// Default value: 1.
// Data range: 0 to 255.
// Constraints: This is a pre-set threshold for collecting certain level of the red/green/blue stat.
// Effect: Lower values allow stats with lower r, g, b values be collected.
//
// Variable name: white_stat_y_threshold_high.
// The Y threshold for a region to be a white stat.
// Default value: white_stat_y_threshold_high=245.
// Data range: 0 to 255.
// Constraints: None.
// Effect: The upper limit for collecting white stat.
//         Too high will involve saturated stat,
//         and too low may reduce white stat collection accuracy.
//
// Variable names: threshold_extreme_b_percent, threshold_extreme_r_percent.
// Threshold of the blue or red extreme stat counts.
// Default value: 0.1
// Data range: 0 to 1.
// Constraints: None.
// Effect: Higher value requires a higher number of the collected
//         extreme stats to be recognized as an extreme color case.
//
// Variable name: threshold_compact_cluster.
// Compact cluster threshold.
// Default value: 60.
// Data range: 0 to 1000.
// Constraints: None.
// Effect: This is the threshold of measured distance from outlier sample grid to the average.
//         If the measured maximum distance is lower than this threshold, a compact cluster is recognized.
//         Therefore, a too high threshod results in false-alarm compact cluster recognition,
//         and too low threshold may result in missed detection on the compact cluters.
//
// Variable name: compact_to_grey_dis.
// Outlier compact cluster distance to grey zone.
// Default value: 4.
// Data range: 0 to 100.
// Constraints: None
// Effect: Lower value requires the recognized compact cluster is
//         closer to the grey zone.
//
// Variable name: threshold_compact_cluster_valid.
// Radius of the compact cluster within grey zone.
// Default value: 4.
// Data range: 0 to 100.
// Constraints: None.
// Effect: Lower value requires that the recognized compact cluster have a smaller radius.
//
// Variable name: dominant_cluster_threshold.
// Dominant cluster threshold.
// Default value: 4.
// Data range: 0 to 1000.
// Constraints: None
// Effect: This threshold decides on if there is a dominant cluster or not.
//         Higher threshold gives higher requirement on the cluster counts
//         to be recognized as a dominant cluster.
//
// Variable name: distance_weight_table[121].
// Distance weight table.
// Data range: 0 to 3888.
// Constraints: None
// Effect: This array is used to control the distance weighting.  The index to the LUT is the grid distance.
//         If the outlier distance is N, only the first N entries of this weight table is non-zero, and all other entries are 0s.
//         With a Gaussian kernel, the stat closer to reference points are given higher weight than stat farther away.
//         With equal weight, all samples in the grey zone are treated equally.
//
// Variable name: outdoor_adjustment.
// Adjustable parameters for outdoor exposure range control.
// Default value: 30.
// Data range: 0 to 140.
// Constraints: None.
// Effect: This parameter adjusts the range of the exposure in outdoor conditions.
//         Higher values give narrower range for Noon and D50 exposure range but larger D65 exposure range.
//         This parameter is used for easy exposure adjustment for different sensors.
//
// Variable name: exposure_adjustment.
// Interpolation range adjustment on the boundary of two different AWB decisions.
// Default value: 5.
// Data range: 0 to 140.
// Constraints: None.
// Effect: This parameter adjusts the interpolation range on the boundary of two different AWB decisions based on exposure.
//         Higher values give a larger interpolation range which results in a smoother AWB decision change.
//
// Variable name: outlier_valid_ymax_ratio.
// Check if Y max in outliers is outlier_valid_ymax_ratio
// times higher than the Y max in valid samples.
// Default value: 3.
// Data range: 1 to 10.
// Constraints: None.
// Effect: If outlier Y max is outlier_valid_ymax times more than the Y max in valid samples,
//         set white world decision to be -1. higher value requires a higher threshold for this decision.
//
// Variable names: cluster_high_pec, cluster_mid_pec, cluster_low_pec
// Cluster percentage to determine dominant light in heuristics.
// Default values: 0.40, 0.25, 0.15;
// Data range: 0 to 1
// Constraints: None.
// Effect: These three parameters set three boundaries to recognize the dominant cluster in heuristics.
//         Higher values require a larger number of cluster counts. For example, cluster_high_pec=0.25 requires
//         the corresponding cluster to have a 25 percentage of the total-cluster-counts to proceed to the
//         corresponding AWB decision making. While cluster_low_pec=0.1 only requires 10 percentage of the
//         total-cluster counts to proceed to the corresponding AWB decision making.
//
// Variable name: weight_vector.
// Weight vector corresponding to different range of exposure index.
// Four columns correspond to four exp index ranges: [0,outdoor], [outdoor, inoutdoor], [inoutdoor, indoor], [indoor, maxindex].
// Default value: {  7, 10, 7,  4,   /* D65 30 */
//                   8, 10, 8,  5,   /* D75 30*/
//                   1,  1, 1,  2,   /* A */
//                   1,  1, 5, 10,   /*5 wf 3800*/
//                   1,  1, 3,  9,   /*3 cf 4000*/
//                   1,  1, 1,  2,   /* H */
//                  10,  6, 6,  3,   /* D50 30*/
//                   1,  1, 1,  1,   /* custom f */
//                  10,  1, 1,  1,   /* noon */
//                   8, 10, 8,  1,   /* daylight hybrid 1*/
//                   8, 10, 1,  8,   /* daylight hybrid 2 */
//                   1,  1, 2,  3,   /* A light line 1*/
//                   1,  1, 1,  2,   /* A light line 2*/
//                   1,  1, 5, 10,   /* F line */
//                   1,  1, 1,  1,   /* Custom day */
//                   1,  1, 1,  1,   /* Custom A */
//                   1,  1, 1,  1  } /* U30 */
// Data range: 0 to 10.
// Constraints: None.
// Effect: Higher values give higher weight to the stat at the exposure index in the corresponding range.
//
// Variable names: ref_b_bg_tl84, ref_r_rg_a.
// This reference R, B 's r/g b/g are for 8k FFA; it needs to be tuned for other sensors.
// Corresponding rolloff table should be applied when doing the measurement.
// Default value: these two values are specifically estimated for the corresponding sensor. Default value for 8k foxcon sensor are:  ref_b_bg_tl84 = 1.4049; ref_r_rg_a = 3.1547;
// Data range: 0 to 10
// Constraints: None.
// Effect: Accurately estimated values decide the stat collected for extreme blue and red.
//         For calibration of these two values, take full-view MCC chart under TL84 and A lighting.
//         Apply correct rolloff table and then measure the blues b/g from the MCC taken under TL84.
//         Measure the reds r/g from the MCC taken under A.
//
// Variable names: extreme_range_perc_b, extreme_range_perc_r.
// Extreme blue and red threshold.
// Default value: 1.
// Data range: 0 to 10.
// Constraints: None.
// Effect: Higher values increase the boundary of collecting extreme red and blue stat.
//         Lower values reduce the boundary of collecting the extreme stat.
//
// Variable name: threshold_compact_cluster_grey.
// Threshold of distance from the outlier compact cluster to the grey zone.
// Default value: 20.
// Data range: 1 to 1000.
// Constraints: None.
// Effect: Lower value requires the distance from the outlier compact cluster to be closer to the grey zone; higher value
//         loosens this requirement by allowing a farther outlier compact cluster to be recognized as a compact cluster.
//
// Variable names: camera_preview_aggressiveness, camcorder_aggressiveness.
// Step size for temporal filter for camera preview and camcorder mode
// Applicable operation mode: camera preview and camcorder
// Default value: 0.1
// Data range: 0 to 1.
// Constraints: None.
// Effect: Slow down or speed up the awb temporal domain convergence.
//
// Variable name: blue_sky_pec.
// Percentage of the extreme blue stats.
// Default value: 0.20
// Data range: 0 to 1.
// Constraints: None.
// Effect: If the extreme blue stats exceed this percentage of all the collected stats, the blue sky prevention is to be conducted
//         to prevent purple sky. The smaller the percentage, the easier the purple sky prevention will be performed when AWB decision
//         is day light.
//
// Variable name: blue_sky_pec_buffer.
// Percentage of the extreme blue stats.
// Default value: 0.15
// Data range: 0 to awb2_blue_sky_pec.
// Constraints: None.
// Effect: This percentage is to set a buffer zone between doing the purple sky prevention and not doing it. The closer to awb2_blue_sky_pec,
//         the smaller the buffer zone is. The smaller it is than awb2_blue_sky_pec, the larger the buffer zone is.
//
// Variable name: slope_factor_m.
// The parameter to adjust the slope of the projection line from center of the green stats to the day light line.
// Default value: 1.5
// Data range:
// Constraints: None.
// Effect: The smaller the value, the smaller slope the projection line has. The resulted green scene images go towards the bluish green direction.
//         The larger the value, the larger slope the projection line has. The resulted green scene images go towards the yellowish green color direction.
/******************************************************************/


/*********************************************************************/
// Feature name :
//
// R/G ratio, B/G ratio: AWB referecne points used for auto WB calculation.
//
//Red Gain Adjust,Blue Gain Adjust: Additional gain applied for snapshot only.
/*********************************************************************/

   /* AWB Reference Points w/HW */
   {
      /* D65 AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* Shade AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* A AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* TL84 AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* CoolWhite AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* Horizon AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* D50 AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* Cust. Fluor. AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* Noon AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* Custom Daylight AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* Custom A AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
      /* U30 AWB Reference Point */
      {
         `xf4`,   /* R/G ratio */
         `xf4`,   /* B/G ratio */
      },
   },
   /* LED Gain Adjust */
   {
      `xf4`, /* Red */
      `xf4`, /* Blue */
   },
   /* Strobe Gain Adjust */
   {
      `xf4`, /* Red */
      `xf4`, /* Blue */
   },
   /* AWB Gain Adjust */
   {
      /* D65 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* D75 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* A */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* TL84 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* CW */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Horizon */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* D50 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Cust Flo */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Noon */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Daylight */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Cust A */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* U30 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
   },
   /* AWB Lowlight Gain Adjust */
   {
      /* D65 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* D75 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* A */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* TL84 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* CW */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Horizon */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* D50 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Cust Flo */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Noon */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Daylight */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* Cust A */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
      /* U30 */
      {
         `xf4`, /* Red */
         `xf4`, /* Blue */
      },
   },

/*********************************************************************/
// Comment:
// Indoor and outdoor index are the parameters used in AWB algorithm in
// a variety of heuristics. We do not recommend the user change these values.
/*********************************************************************/

   `xu4`, /* Indoor Index */
   `xu4`, /* Outdoor Index */

/*********************************************************************/
// Feature name :
// Blue gain adj ratio is used for Snow and Beach best shot modes only. This factor
// is applied on top of the blue WB gain determined by AWB algorithm.
// Range: 0.7 to 1.5.
/*********************************************************************/

   `xf4`, /* Snow Blue Gain Adj Ratio */
   `xf4`, /* Beach Blue Gain Adj Ratio */

/*********************************************************************/
// Feature name :
// The following group of parameters are used by AWB algorithm. We do not
// recommend the user modify them.
/*********************************************************************/

   `xu4`, /* Outlier Distance */
   `xi4`, /* Green Zone Offset RG */
   `xi4`, /* Green Zone Offset BG */
   `xu1`, /* Num Frames to skip after changing VFE */

/*********************************************************************/
// Feature name :
// The final WB gain applied to the system is mandated to be between min
// and max WB values.  We do not recommend the user change the values.
/*********************************************************************/
`xa`
   /* AWB Min Gains - RGB */
   {`xf4a3`},
   /* AWB Max Gains - RGB */
   {`xf4a3`},
   `xf4`, /* AWB Aggressiveness */
   `xu4`, /* AWB Self-Calibrate */

/******************************************************************************/
// Feature name : AWB self calibration
// variable name:
// Adjust amount of adjustment allowed for AWB self calibration
// applicale chipset(s): all MSM
// applicable operation mode: preview
// default value: high=1.15
// default value: low=0.9
// data range: high (1.0, 1.2), low (0.8, 1.0)
// constraints:
// effect: larger high = larger adjustment, smaller low = larger adjustment
/******************************************************************************/

   `xf4`, /* AWB Self-Calibrate */
   `xf4`, /* AWB Self-Calibrate Adjust Ratio Low */
   /* Purple Prevent */
   {

/******************************************************************************/
// Feature name : AWB Extended
// applicable chipset:  all VFEs.
// applicable operation mode: View finder and snapshot.
//
// variable name: AWB_purple_prevent_enable
// Enables the feature.
// default value: 1
// data range: 0 and 1
// constraints: None
//
// variable name: control_purple_prevent
// Control with gain or lux_index
// default Value: 0
// Data Range: 0 or 1.
// constraints: None
// effect: use gain or lux_index for control purple sky prevention
//
// variable name: purple_prevent_trigger
// Control the purple sky prevention adjustment trigger
// default Value: between  outdoor index and outdoor index
// Data Range: integers 0 to a few hundreds.
// constraints: only for bright outdoor
// effect: smaller index values make the purple sky prevention harder to take effect. (has to be very bright)
//
// variable name: purple_sky_prevention_bg_threshold
// Control the purple sky prevention adjustment
// default Value: BG ratio of D50
// Data Range: 0 to 2
// constraints: around D50
// effect: smaller index values make the adjustment larger.
/******************************************************************************/

      `xu4`, /* Enable */
      `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */
      /* Trigger Point */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },
      `xf4`, /* Sky Prevention BG Thresh */
   },
   `xu4`, /* Enable AWB Module Cal */
   /* AWB Motion Sensor */
   {

/******************************************************************************/
// Feature name : AWB_motion_sensor_type to aide AWB in determining a change in
//           scene.
// Applicable chipset: MSM7x30, QSD8x60, and newer chipsets.
// Applicable operation mode: Viewfinder and video.
//
// Variable name: awb_gyro_trigger.
// Used to control how scene change should be detected for AEC
// 3A version: 3.0.
// Default value: 0.0.
// Data range: -16000.0 to +16000.0.
// Constraints: None .
// Effect: The bigger the value is, the less sensitive AEC response to
//         gyro output value.
//
// Variable name: awb_accelerometer_trigger.
// Used to control how scene change should be detected for AEC.
// 3A version: 3.0.
// Default value: 0.0.
// Data range: -16000.0 to +16000.0.
// Constraints: None.
// Effect: The bigger the value is, the less sensitive AEC response to
//         accelerometer change.
//
// Variable name: awb_magnetometer_trigger.
// Used to control how scene change should be detected for AEC
// 3A version: 3.0.
// Default value: 0.0.
// Data range: 0.0 to 360.0.
// Constraints: None.
// Effect: The bigger the value is, the less sensitive AEC response to
//         magnetic field change.
//
// Variable name: awb_DIS_motion_vector_trigger.
// Used to control how scene change should be detected for AEC.
// 3A version: 3.0.
// Default value: 0.0.
// Data range: -16000.0 to +16000.0.
// Constraints: None.
// Effect: The bigger the value is, the less sensitive AEC response to
//         digital image stabilization movement/compensation value.
/******************************************************************************/

      `xf4`, /* Gyro Trigger */
      `xf4`, /* Accelerometer Trigger */
      `xf4`, /* Magnetometer Trigger */
      `xf4`, /* DIS Motion Vector Trigger */
   },
   `xf4`, /* LED/Strobe Adjustment Factor */
   `xu1+3`, /* Interpolate Gain Adj Enable */
   /* Lowlight LUT */
   {
      `xu1+3`, /* Enable */
      {
         /* Entry 0 */
         {
            `xu4`, /* Lux Index */
            `xf4`, /* Green RG Offset Adj */
            `xf4`, /* Green BG Offset Adj */
            `xf4`, /* Outlier Dist Adj */
         },
         /* Entry 1 */
         {
            `xu4`, /* Lux Index */
            `xf4`, /* Green RG Offset Adj */
            `xf4`, /* Green BG Offset Adj */
            `xf4`, /* Outlier Dist Adj */
         },
         /* Entry 2 */
         {
            `xu4`, /* Lux Index */
            `xf4`, /* Green RG Offset Adj */
            `xf4`, /* Green BG Offset Adj */
            `xf4`, /* Outlier Dist Adj */
         },
         /* Entry 3 */
         {
            `xu4`, /* Lux Index */
            `xf4`, /* Green RG Offset Adj */
            `xf4`, /* Green BG Offset Adj */
            `xf4`, /* Outlier Dist Adj */
         },
         /* Entry 4 */
         {
            `xu4`, /* Lux Index */
            `xf4`, /* Green RG Offset Adj */
            `xf4`, /* Green BG Offset Adj */
            `xf4`, /* Outlier Dist Adj */
         },
         /* Entry 5 */
         {
            `xu4`, /* Lux Index */
            `xf4`, /* Green RG Offset Adj */
            `xf4`, /* Green BG Offset Adj */
            `xf4`, /* Outlier Dist Adj */
         },
      },
   },

/******************************************************************************/
// Feature name : Match LED Level
// Applicale chipset: MSM8x30 and later.
// Applicable operation mode:  For video and snapshot.
//
// This is the feature to match dual LED flash with the ambient lighting.
//
// Desription of variables in chromatix_match_LED_lighting_table
// structure.
//
// Variable names: table_size, CCT_control[table_size-1].
// The three values for the table entries:
// The color temperature
// The LED1 current configuration for LED controller IC
// The LED2 current configuration for LED controller IC
/******************************************************************************/

   /* Mix LED Table */
   {
      `xu2`, /* Table Size */
      {
         /* Entry 0 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 1 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 2 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 3 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 4 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 5 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 6 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 7 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 8 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 9 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 10 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 11 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 12 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 13 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 14 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
         /* Entry 15 */
         {
            `xu2`, /* CCT */
            `xu2`, /* LED1 Config */
            `xu2`, /* LED2 Config */
         },
      },
   },`xa`
   `xu4`, /* Bright Green Percentage */
   `xu4`, /* Dark Green Percentage */
   `xu4`, /* Dark R Threshold */
   `xu4`, /* Dark G Threshold */
   `xu4`, /* Dark B Threshold */
   `xu4`, /* White Stat Y Threshold High */
   `xf4`, /* Threshold Extreme B Percent */
   `xf4`, /* Threshold Extreme R Percent */
   `xu4`, /* Threshold Compact Cluster */
   `xu4`, /* Compact To Grey DIS */
   `xu4`, /* Threshold Compact Cluster Valid */
   `xu4`, /* Dominant Cluster Threshold */
   /* Dist Weight Table */
   {
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4a8`,
      `xu4`
   },
   `xu4`, /* Outdoor Adjustment */
   `xu4`, /* Exposure Adjustment */
   `xf4`, /* Outlier Valid yMax */
   `xf4`, /* Cluster High PEC */
   `xf4`, /* Cluster Mid PEC */
   `xf4`, /* Cluster Low PEC */
   /* Weight Vector */
   {
      {`xu4a4`}, /* D65 */
      {`xu4a4`}, /* D75 */
      {`xu4a4`}, /* A */
      {`xu4a4`}, /* Warm Fluorescent */
      {`xu4a4`}, /* Cool Fluorescent */
      {`xu4a4`}, /* Horizon */
      {`xu4a4`}, /* D50 */
      {`xu4a4`}, /* Custom Fluorescent */
      {`xu4a4`}, /* Noon */
      {`xu4a4`}, /* Custom Daylight */
      {`xu4a4`}, /* Custom A */
      {`xu4a4`}, /* U30 */
      {`xu4a4`}, /* Daylight Hybrid 1 */
      {`xu4a4`}, /* Daylight Hybrid 2 */
      {`xu4a4`}, /* A Line 1 */
      {`xu4a4`}, /* A Line 2 */
      {`xu4a4`}, /* F Line */
   },
   `xf4`, /* Ref B BG Tl84 */
   `xf4`, /* Ref R RG A */
   `xf4`, /* Extreme Range Offset B */
   `xf4`, /* Extreme Range Offset R */
   `xu4`, /* Threshold Compact Cluster Grey */
   `xf4`, /* Blue Sky Percent */
   `xf4`, /* Blue Sky Percent Buffer */
   `xf4`, /* Slope Factor M */
   `xf4`, /* Extreme MCC Blue Threshold */
},
/* AEC */
{
   `xu4`, /* Software Type */
   `xf4`, /* CC Global Gain */

/*********************************************************************/
// Comments:
// Variable name: exp_table_flag
// This parameter is unused.
//
// Variable name: valid_entries
// Number of entries in the exposure table, not counting EV lowlight section.
//
// Variable name: aec_enable_digital_gain_for_EV_lowlight
// Indicates if extended exp table is used for EV lowlight case.
// Default: 1.
// Data range : 0 or 1.
//
// Variable name: exp_index_for_digital_gain_for_EV_lowlight;
// The maximum exposure table size when EV lowlight in enabled.
// It needs to be in sync with the table contents.
//
// Variable name: exposure_entries
// Exposure table contains 2 columns. The first column is real gain values
//    right shifted 8 bits. For example, 256 means gain of 1.0. The 2nd colum
//    is sensor integration (exposure) time in terms of number of lines.
//    Exposure table is generated by Chromatix or sensor driver team.
//    It can be regenerated in Chromatix tool by specifying different max gain
//    and max line count.  We do not recommend user to manually modify it because it
//    potentially will change trigger points for many parameters.
/*********************************************************************/

   /* Exposure Table */
   {
      `xu1+1`, /* Use Digital Gain */
      /* Exposure Table */
      `xu2`, /* Max Exp Index for Digital Gain for EV Lowlight */
      `xu4`, /* Enable Digital Gain for EV Lowlight */
      `xu2+2`, /* Max Exposure Table entries */
      {
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=0   */
         {`xu2+2`, `xu4`},   /* Gain= 1.031   Exposure Index=1   */
         {`xu2+2`, `xu4`},   /* Gain= 1.063   Exposure Index=2   */
         {`xu2+2`, `xu4`},   /* Gain= 1.094   Exposure Index=3   */
         {`xu2+2`, `xu4`},   /* Gain= 1.125   Exposure Index=4   */
         {`xu2+2`, `xu4`},   /* Gain= 1.160   Exposure Index=5   */
         {`xu2+2`, `xu4`},   /* Gain= 1.195   Exposure Index=6   */
         {`xu2+2`, `xu4`},   /* Gain= 1.230   Exposure Index=7   */
         {`xu2+2`, `xu4`},   /* Gain= 1.266   Exposure Index=8   */
         {`xu2+2`, `xu4`},   /* Gain= 1.305   Exposure Index=9   */
         {`xu2+2`, `xu4`},   /* Gain= 1.344   Exposure Index=10   */
         {`xu2+2`, `xu4`},   /* Gain= 1.383   Exposure Index=11   */
         {`xu2+2`, `xu4`},   /* Gain= 1.426   Exposure Index=12   */
         {`xu2+2`, `xu4`},   /* Gain= 1.469   Exposure Index=13   */
         {`xu2+2`, `xu4`},   /* Gain= 1.512   Exposure Index=14   */
         {`xu2+2`, `xu4`},   /* Gain= 1.559   Exposure Index=15   */
         {`xu2+2`, `xu4`},   /* Gain= 1.605   Exposure Index=16   */
         {`xu2+2`, `xu4`},   /* Gain= 1.652   Exposure Index=17   */
         {`xu2+2`, `xu4`},   /* Gain= 1.703   Exposure Index=18   */
         {`xu2+2`, `xu4`},   /* Gain= 1.754   Exposure Index=19   */
         {`xu2+2`, `xu4`},   /* Gain= 1.805   Exposure Index=20   */
         {`xu2+2`, `xu4`},   /* Gain= 1.859   Exposure Index=21   */
         {`xu2+2`, `xu4`},   /* Gain= 1.914   Exposure Index=22   */
         {`xu2+2`, `xu4`},   /* Gain= 1.973   Exposure Index=23   */
         {`xu2+2`, `xu4`},   /* Gain= 1.016   Exposure Index=24   */
         {`xu2+2`, `xu4`},   /* Gain= 1.047   Exposure Index=25   */
         {`xu2+2`, `xu4`},   /* Gain= 1.078   Exposure Index=26   */
         {`xu2+2`, `xu4`},   /* Gain= 1.109   Exposure Index=27   */
         {`xu2+2`, `xu4`},   /* Gain= 1.145   Exposure Index=28   */
         {`xu2+2`, `xu4`},   /* Gain= 1.180   Exposure Index=29   */
         {`xu2+2`, `xu4`},   /* Gain= 1.215   Exposure Index=30   */
         {`xu2+2`, `xu4`},   /* Gain= 1.250   Exposure Index=31   */
         {`xu2+2`, `xu4`},   /* Gain= 1.289   Exposure Index=32   */
         {`xu2+2`, `xu4`},   /* Gain= 1.328   Exposure Index=33   */
         {`xu2+2`, `xu4`},   /* Gain= 1.367   Exposure Index=34   */
         {`xu2+2`, `xu4`},   /* Gain= 1.410   Exposure Index=35   */
         {`xu2+2`, `xu4`},   /* Gain= 1.453   Exposure Index=36   */
         {`xu2+2`, `xu4`},   /* Gain= 1.496   Exposure Index=37   */
         {`xu2+2`, `xu4`},   /* Gain= 1.027   Exposure Index=38   */
         {`xu2+2`, `xu4`},   /* Gain= 1.059   Exposure Index=39   */
         {`xu2+2`, `xu4`},   /* Gain= 1.090   Exposure Index=40   */
         {`xu2+2`, `xu4`},   /* Gain= 1.121   Exposure Index=41   */
         {`xu2+2`, `xu4`},   /* Gain= 1.156   Exposure Index=42   */
         {`xu2+2`, `xu4`},   /* Gain= 1.191   Exposure Index=43   */
         {`xu2+2`, `xu4`},   /* Gain= 1.227   Exposure Index=44   */
         {`xu2+2`, `xu4`},   /* Gain= 1.262   Exposure Index=45   */
         {`xu2+2`, `xu4`},   /* Gain= 1.301   Exposure Index=46   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=47   */
         {`xu2+2`, `xu4`},   /* Gain= 1.035   Exposure Index=48   */
         {`xu2+2`, `xu4`},   /* Gain= 1.066   Exposure Index=49   */
         {`xu2+2`, `xu4`},   /* Gain= 1.098   Exposure Index=50   */
         {`xu2+2`, `xu4`},   /* Gain= 1.129   Exposure Index=51   */
         {`xu2+2`, `xu4`},   /* Gain= 1.164   Exposure Index=52   */
         {`xu2+2`, `xu4`},   /* Gain= 1.199   Exposure Index=53   */
         {`xu2+2`, `xu4`},   /* Gain= 1.234   Exposure Index=54   */
         {`xu2+2`, `xu4`},   /* Gain= 1.016   Exposure Index=55   */
         {`xu2+2`, `xu4`},   /* Gain= 1.047   Exposure Index=56   */
         {`xu2+2`, `xu4`},   /* Gain= 1.078   Exposure Index=57   */
         {`xu2+2`, `xu4`},   /* Gain= 1.109   Exposure Index=58   */
         {`xu2+2`, `xu4`},   /* Gain= 1.145   Exposure Index=59   */
         {`xu2+2`, `xu4`},   /* Gain= 1.180   Exposure Index=60   */
         {`xu2+2`, `xu4`},   /* Gain= 1.012   Exposure Index=61   */
         {`xu2+2`, `xu4`},   /* Gain= 1.043   Exposure Index=62   */
         {`xu2+2`, `xu4`},   /* Gain= 1.074   Exposure Index=63   */
         {`xu2+2`, `xu4`},   /* Gain= 1.105   Exposure Index=64   */
         {`xu2+2`, `xu4`},   /* Gain= 1.137   Exposure Index=65   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=66   */
         {`xu2+2`, `xu4`},   /* Gain= 1.035   Exposure Index=67   */
         {`xu2+2`, `xu4`},   /* Gain= 1.066   Exposure Index=68   */
         {`xu2+2`, `xu4`},   /* Gain= 1.098   Exposure Index=69   */
         {`xu2+2`, `xu4`},   /* Gain= 1.129   Exposure Index=70   */
         {`xu2+2`, `xu4`},   /* Gain= 1.016   Exposure Index=71   */
         {`xu2+2`, `xu4`},   /* Gain= 1.047   Exposure Index=72   */
         {`xu2+2`, `xu4`},   /* Gain= 1.078   Exposure Index=73   */
         {`xu2+2`, `xu4`},   /* Gain= 1.109   Exposure Index=74   */
         {`xu2+2`, `xu4`},   /* Gain= 1.016   Exposure Index=75   */
         {`xu2+2`, `xu4`},   /* Gain= 1.047   Exposure Index=76   */
         {`xu2+2`, `xu4`},   /* Gain= 1.078   Exposure Index=77   */
         {`xu2+2`, `xu4`},   /* Gain= 1.109   Exposure Index=78   */
         {`xu2+2`, `xu4`},   /* Gain= 1.027   Exposure Index=79   */
         {`xu2+2`, `xu4`},   /* Gain= 1.059   Exposure Index=80   */
         {`xu2+2`, `xu4`},   /* Gain= 1.090   Exposure Index=81   */
         {`xu2+2`, `xu4`},   /* Gain= 1.020   Exposure Index=82   */
         {`xu2+2`, `xu4`},   /* Gain= 1.051   Exposure Index=83   */
         {`xu2+2`, `xu4`},   /* Gain= 1.082   Exposure Index=84   */
         {`xu2+2`, `xu4`},   /* Gain= 1.023   Exposure Index=85   */
         {`xu2+2`, `xu4`},   /* Gain= 1.055   Exposure Index=86   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=87   */
         {`xu2+2`, `xu4`},   /* Gain= 1.035   Exposure Index=88   */
         {`xu2+2`, `xu4`},   /* Gain= 1.066   Exposure Index=89   */
         {`xu2+2`, `xu4`},   /* Gain= 1.020   Exposure Index=90   */
         {`xu2+2`, `xu4`},   /* Gain= 1.051   Exposure Index=91   */
         {`xu2+2`, `xu4`},   /* Gain= 1.012   Exposure Index=92   */
         {`xu2+2`, `xu4`},   /* Gain= 1.043   Exposure Index=93   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=94   */
         {`xu2+2`, `xu4`},   /* Gain= 1.039   Exposure Index=95   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=96   */
         {`xu2+2`, `xu4`},   /* Gain= 1.039   Exposure Index=97   */
         {`xu2+2`, `xu4`},   /* Gain= 1.012   Exposure Index=98   */
         {`xu2+2`, `xu4`},   /* Gain= 1.043   Exposure Index=99   */
         {`xu2+2`, `xu4`},   /* Gain= 1.020   Exposure Index=100   */
         {`xu2+2`, `xu4`},   /* Gain= 1.051   Exposure Index=101   */
         {`xu2+2`, `xu4`},   /* Gain= 1.027   Exposure Index=102   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=103   */
         {`xu2+2`, `xu4`},   /* Gain= 1.039   Exposure Index=104   */
         {`xu2+2`, `xu4`},   /* Gain= 1.023   Exposure Index=105   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=106   */
         {`xu2+2`, `xu4`},   /* Gain= 1.039   Exposure Index=107   */
         {`xu2+2`, `xu4`},   /* Gain= 1.027   Exposure Index=108   */
         {`xu2+2`, `xu4`},   /* Gain= 1.016   Exposure Index=109   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=110   */
         {`xu2+2`, `xu4`},   /* Gain= 1.039   Exposure Index=111   */
         {`xu2+2`, `xu4`},   /* Gain= 1.031   Exposure Index=112   */
         {`xu2+2`, `xu4`},   /* Gain= 1.023   Exposure Index=113   */
         {`xu2+2`, `xu4`},   /* Gain= 1.020   Exposure Index=114   */
         {`xu2+2`, `xu4`},   /* Gain= 1.016   Exposure Index=115   */
         {`xu2+2`, `xu4`},   /* Gain= 1.012   Exposure Index=116   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=117   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=118   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=119   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=120   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=121   */
         {`xu2+2`, `xu4`},   /* Gain= 1.012   Exposure Index=122   */
         {`xu2+2`, `xu4`},   /* Gain= 1.016   Exposure Index=123   */
         {`xu2+2`, `xu4`},   /* Gain= 1.020   Exposure Index=124   */
         {`xu2+2`, `xu4`},   /* Gain= 1.023   Exposure Index=125   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=126   */
         {`xu2+2`, `xu4`},   /* Gain= 1.012   Exposure Index=127   */
         {`xu2+2`, `xu4`},   /* Gain= 1.020   Exposure Index=128   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=129   */
         {`xu2+2`, `xu4`},   /* Gain= 1.012   Exposure Index=130   */
         {`xu2+2`, `xu4`},   /* Gain= 1.020   Exposure Index=131   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=132   */
         {`xu2+2`, `xu4`},   /* Gain= 1.020   Exposure Index=133   */
         {`xu2+2`, `xu4`},   /* Gain= 1.012   Exposure Index=134   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=135   */
         {`xu2+2`, `xu4`},   /* Gain= 1.016   Exposure Index=136   */
         {`xu2+2`, `xu4`},   /* Gain= 1.012   Exposure Index=137   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=138   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=139   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=140   */
         {`xu2+2`, `xu4`},   /* Gain= 1.016   Exposure Index=141   */
         {`xu2+2`, `xu4`},   /* Gain= 1.016   Exposure Index=142   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=143   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=144   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=145   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=146   */
         {`xu2+2`, `xu4`},   /* Gain= 1.012   Exposure Index=147   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=148   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=149   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=150   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=151   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=152   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=153   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=154   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=155   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=156   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=157   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=158   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=159   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=160   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=161   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=162   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=163   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=164   */
         {`xu2+2`, `xu4`},   /* Gain= 1.008   Exposure Index=165   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=166   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=167   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=168   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=169   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=170   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=171   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=172   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=173   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=174   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=175   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=176   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=177   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=178   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=179   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=180   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=181   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=182   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=183   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=184   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=185   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=186   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=187   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=188   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=189   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=190   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=191   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=192   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=193   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=194   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=195   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=196   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=197   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=198   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=199   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=200   */
         {`xu2+2`, `xu4`},   /* Gain= 1.004   Exposure Index=201   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=202   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=203   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=204   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=205   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=206   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=207   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=208   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=209   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=210   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=211   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=212   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=213   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=214   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=215   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=216   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=217   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=218   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=219   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=220   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=221   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=222   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=223   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=224   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=225   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=226   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=227   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=228   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=229   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=230   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=231   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=232   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=233   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=234   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=235   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=236   */
         {`xu2+2`, `xu4`},   /* Gain= 1.000   Exposure Index=237   */
         {`xu2+2`, `xu4`},   /* Gain= 1.012   Exposure Index=238   */
         {`xu2+2`, `xu4`},   /* Gain= 1.043   Exposure Index=239   */
         {`xu2+2`, `xu4`},   /* Gain= 1.074   Exposure Index=240   */
         {`xu2+2`, `xu4`},   /* Gain= 1.105   Exposure Index=241   */
         {`xu2+2`, `xu4`},   /* Gain= 1.137   Exposure Index=242   */
         {`xu2+2`, `xu4`},   /* Gain= 1.172   Exposure Index=243   */
         {`xu2+2`, `xu4`},   /* Gain= 1.207   Exposure Index=244   */
         {`xu2+2`, `xu4`},   /* Gain= 1.242   Exposure Index=245   */
         {`xu2+2`, `xu4`},   /* Gain= 1.281   Exposure Index=246   */
         {`xu2+2`, `xu4`},   /* Gain= 1.320   Exposure Index=247   */
         {`xu2+2`, `xu4`},   /* Gain= 1.359   Exposure Index=248   */
         {`xu2+2`, `xu4`},   /* Gain= 1.398   Exposure Index=249   */
         {`xu2+2`, `xu4`},   /* Gain= 1.441   Exposure Index=250   */
         {`xu2+2`, `xu4`},   /* Gain= 1.484   Exposure Index=251   */
         {`xu2+2`, `xu4`},   /* Gain= 1.527   Exposure Index=252   */
         {`xu2+2`, `xu4`},   /* Gain= 1.574   Exposure Index=253   */
         {`xu2+2`, `xu4`},   /* Gain= 1.621   Exposure Index=254   */
         {`xu2+2`, `xu4`},   /* Gain= 1.668   Exposure Index=255   */
         {`xu2+2`, `xu4`},   /* Gain= 1.719   Exposure Index=256   */
         {`xu2+2`, `xu4`},   /* Gain= 1.770   Exposure Index=257   */
         {`xu2+2`, `xu4`},   /* Gain= 1.824   Exposure Index=258   */
         {`xu2+2`, `xu4`},   /* Gain= 1.879   Exposure Index=259   */
         {`xu2+2`, `xu4`},   /* Gain= 1.934   Exposure Index=260   */
         {`xu2+2`, `xu4`},   /* Gain= 1.992   Exposure Index=261   */
         {`xu2+2`, `xu4`},   /* Gain= 2.051   Exposure Index=262   */
         {`xu2+2`, `xu4`},   /* Gain= 2.113   Exposure Index=263   */
         {`xu2+2`, `xu4`},   /* Gain= 2.176   Exposure Index=264   */
         {`xu2+2`, `xu4`},   /* Gain= 2.242   Exposure Index=265   */
         {`xu2+2`, `xu4`},   /* Gain= 2.309   Exposure Index=266   */
         {`xu2+2`, `xu4`},   /* Gain= 2.379   Exposure Index=267   */
         {`xu2+2`, `xu4`},   /* Gain= 2.449   Exposure Index=268   */
         {`xu2+2`, `xu4`},   /* Gain= 2.523   Exposure Index=269   */
         {`xu2+2`, `xu4`},   /* Gain= 2.598   Exposure Index=270   */
         {`xu2+2`, `xu4`},   /* Gain= 2.676   Exposure Index=271   */
         {`xu2+2`, `xu4`},   /* Gain= 2.758   Exposure Index=272   */
         {`xu2+2`, `xu4`},   /* Gain= 2.840   Exposure Index=273   */
         {`xu2+2`, `xu4`},   /* Gain= 2.926   Exposure Index=274   */
         {`xu2+2`, `xu4`},   /* Gain= 3.012   Exposure Index=275   */
         {`xu2+2`, `xu4`},   /* Gain= 3.102   Exposure Index=276   */
         {`xu2+2`, `xu4`},   /* Gain= 3.195   Exposure Index=277   */
         {`xu2+2`, `xu4`},   /* Gain= 3.293   Exposure Index=278   */
         {`xu2+2`, `xu4`},   /* Gain= 3.391   Exposure Index=279   */
         {`xu2+2`, `xu4`},   /* Gain= 3.492   Exposure Index=280   */
         {`xu2+2`, `xu4`},   /* Gain= 3.598   Exposure Index=281   */
         {`xu2+2`, `xu4`},   /* Gain= 3.707   Exposure Index=282   */
         {`xu2+2`, `xu4`},   /* Gain= 3.816   Exposure Index=283   */
         {`xu2+2`, `xu4`},   /* Gain= 3.930   Exposure Index=284   */
         {`xu2+2`, `xu4`},   /* Gain= 4.047   Exposure Index=285   */
         {`xu2+2`, `xu4`},   /* Gain= 4.168   Exposure Index=286   */
         {`xu2+2`, `xu4`},   /* Gain= 4.293   Exposure Index=287   */
         {`xu2+2`, `xu4`},   /* Gain= 4.422   Exposure Index=288   */
         {`xu2+2`, `xu4`},   /* Gain= 4.555   Exposure Index=289   */
         {`xu2+2`, `xu4`},   /* Gain= 4.691   Exposure Index=290   */
         {`xu2+2`, `xu4`},   /* Gain= 4.832   Exposure Index=291   */
         {`xu2+2`, `xu4`},   /* Gain= 4.977   Exposure Index=292   */
         {`xu2+2`, `xu4`},   /* Gain= 5.125   Exposure Index=293   */
         {`xu2+2`, `xu4`},   /* Gain= 5.277   Exposure Index=294   */
         {`xu2+2`, `xu4`},   /* Gain= 5.438   Exposure Index=295   */
         {`xu2+2`, `xu4`},   /* Gain= 5.602   Exposure Index=296   */
         {`xu2+2`, `xu4`},   /* Gain= 5.770   Exposure Index=297   */
         {`xu2+2`, `xu4`},   /* Gain= 5.941   Exposure Index=298   */
         {`xu2+2`, `xu4`},   /* Gain= 6.121   Exposure Index=299   */
         {`xu2+2`, `xu4`},   /* Gain= 6.305   Exposure Index=300   */
         {`xu2+2`, `xu4`},   /* Gain= 6.492   Exposure Index=301   */
         {`xu2+2`, `xu4`},   /* Gain= 6.688   Exposure Index=302   */
         {`xu2+2`, `xu4`},   /* Gain= 6.887   Exposure Index=303   */
         {`xu2+2`, `xu4`},   /* Gain= 7.094   Exposure Index=304   */
         {`xu2+2`, `xu4`},   /* Gain= 7.305   Exposure Index=305   */
         {`xu2+2`, `xu4`},   /* Gain= 7.523   Exposure Index=306   */
         {`xu2+2`, `xu4`},   /* Gain= 7.750   Exposure Index=307   */
         {`xu2+2`, `xu4`},   /* Gain= 7.984   Exposure Index=308   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=309   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=310   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=311   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=312   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=313   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=314   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=315   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=316   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=317   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=318   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=319   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=320   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=321   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=322   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=323   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=324   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=325   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=326   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=327   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=328   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=329   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=330   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=331   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=332   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=333   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=334   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=335   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=336   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=337   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=338   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=339   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=340   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=341   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=342   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=343   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=344   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=345   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=346   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=347   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=348   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=349   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=350   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=351   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=352   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=353   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=354   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=355   */
         {`xu2+2`, `xu4`},   /* Gain= 8.000   Exposure Index=356   */
         {`xu2+2`, `xu4`},   /* Gain= 8.238   Exposure Index=357   */
         {`xu2+2`, `xu4`},   /* Gain= 8.484   Exposure Index=358   */
         {`xu2+2`, `xu4`},   /* Gain= 8.738   Exposure Index=359   */
         {`xu2+2`, `xu4`},   /* Gain= 9.000   Exposure Index=360   */
         {`xu2+2`, `xu4`},   /* Gain= 9.270   Exposure Index=361   */
         {`xu2+2`, `xu4`},   /* Gain= 9.547   Exposure Index=362   */
         {`xu2+2`, `xu4`},   /* Gain= 9.832   Exposure Index=363   */
         {`xu2+2`, `xu4`},   /* Gain=10.129   Exposure Index=364   */
         {`xu2+2`, `xu4`},   /* Gain=10.434   Exposure Index=365   */
         {`xu2+2`, `xu4`},   /* Gain=10.746   Exposure Index=366   */
         {`xu2+2`, `xu4`},   /* Gain=11.070   Exposure Index=367   */
         {`xu2+2`, `xu4`},   /* Gain=11.402   Exposure Index=368   */
         {`xu2+2`, `xu4`},   /* Gain=11.746   Exposure Index=369   */
         {`xu2+2`, `xu4`},   /* Gain=12.098   Exposure Index=370   */
         {`xu2+2`, `xu4`},   /* Gain=12.461   Exposure Index=371   */
         {`xu2+2`, `xu4`},   /* Gain=12.836   Exposure Index=372   */
         {`xu2+2`, `xu4`},   /* Gain=13.223   Exposure Index=373   */
         {`xu2+2`, `xu4`},   /* Gain=13.621   Exposure Index=374   */
         {`xu2+2`, `xu4`},   /* Gain=14.031   Exposure Index=375   */
         {`xu2+2`, `xu4`},   /* Gain=14.453   Exposure Index=376   */
         {`xu2+2`, `xu4`},   /* Gain=14.887   Exposure Index=377   */
         {`xu2+2`, `xu4`},   /* Gain=15.332   Exposure Index=378   */
         {`xu2+2`, `xu4`},   /* Gain=15.793   Exposure Index=379   */
         {`xu2+2`, `xu4`},   /* Gain=16.266   Exposure Index=380   */
         {`xu2+2`, `xu4`},   /* Gain=16.754   Exposure Index=381   */
         {`xu2+2`, `xu4`},   /* Gain=17.258   Exposure Index=382   */
         {`xu2+2`, `xu4`},   /* Gain=17.777   Exposure Index=383   */
         {`xu2+2`, `xu4`},   /* Gain=18.313   Exposure Index=384   */
         {`xu2+2`, `xu4`},   /* Gain=18.863   Exposure Index=385   */
         {`xu2+2`, `xu4`},   /* Gain=19.430   Exposure Index=386   */
         {`xu2+2`, `xu4`},   /* Gain=20.012   Exposure Index=387   */
         {`xu2+2`, `xu4`},   /* Gain=20.613   Exposure Index=388   */
         {`xu2+2`, `xu4`},   /* Gain=21.230   Exposure Index=389   */
         {`xu2+2`, `xu4`},   /* Gain=21.867   Exposure Index=390   */
         {`xu2+2`, `xu4`},   /* Gain=22.523   Exposure Index=391   */
         {`xu2+2`, `xu4`},   /* Gain=23.199   Exposure Index=392   */
         {`xu2+2`, `xu4`},   /* Gain=23.895   Exposure Index=393   */
         {`xu2+2`, `xu4`},   /* Gain=24.613   Exposure Index=394   */
         {`xu2+2`, `xu4`},   /* Gain=25.352   Exposure Index=395   */
         {`xu2+2`, `xu4`},   /* Gain=26.113   Exposure Index=396   */
         {`xu2+2`, `xu4`},   /* Gain=26.898   Exposure Index=397   */
         {`xu2+2`, `xu4`},   /* Gain=27.707   Exposure Index=398   */
         {`xu2+2`, `xu4`},   /* Gain=28.539   Exposure Index=399   */
         {`xu2+2`, `xu4`},   /* Gain=29.395   Exposure Index=400   */
         {`xu2+2`, `xu4`},   /* Gain=30.277   Exposure Index=401   */
         {`xu2+2`, `xu4`},   /* Gain=31.188   Exposure Index=402   */
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
         {`xu2+2`, `xu4`},
      },
   },

/******************************************************************************/
// Feature name : AEC Snapshot LUT
// applicale chipset(s):All MSM
// applicable operation mode: Snapshot
//
// variable name: enable
// Allows snapshot to maximize exposure time used when luma target
//  cannot be reached.
// default value: 0
// data range: 0 or 1
// constraints: LUT needs to be entered or wrong snapshot brightness may ocurr.
// effect: Allows snapshot gains and exposure times to be modified by a
//  snapshot_ae_table LUT.
//
// variable name: exposure_stretch_enable
// default value: 0
// data range: 0 and 1
// constraints: None
// effect: Allowing auto stretch will cause snapshot to be brighter than preview
//  when preview does not reach luma target.
//
// variable name: valid_entries
// Number of entries used in ae_table LUT.
// default value: 2
// data range: 2 to 10
// constraints: None
// effect: Higher values allow more entries in LUT.
//
// variable name: snapshot_ae_table
// Each entry contains a triplet of settings:
//  lux_index, gain_trade_off, max_exp_time
// default value: {0, 1/2, 0.200}, {1000, 1/2, 0.200}
// data range: lux_index --> 0 to 1000
//             gain_trade_off --> 1 to .1 (1 means keep preview gain, .1 means reduce gain 10 times)
//             max_exp_time --> 1 (up to number of seconds allowed of exposure)
// constraints: None
// effect: By setting this LUT, at specified lux_idx the gain tradeoff and exposure
//  caps will be used.  At lux_idx between entries, gain trade-offs and exposure
//  caps will be linearly interpolated.
/******************************************************************************/

   /* AEC Snapshot Exposure */
   {
      `xu4`, /* Enable */
      `xu4`, /* Stretch Enable */
      `xu1+3`, /* Valid Entries */
      /* Snapshot Table */
      {
         /* 0 */
         {
            `xu2+2`,
            `xf4`,
            `xf4`
         },
         /* 1 */
         {
            `xu2+2`,
            `xf4`,
            `xf4`
         },
         /* 2 */
         {
            `xu2+2`,
            `xf4`,
            `xf4`
         },
         /* 3 */
         {
            `xu2+2`,
            `xf4`,
            `xf4`
         },
         /* 4 */
         {
            `xu2+2`,
            `xf4`,
            `xf4`
         },
         /* 5 */
         {
            `xu2+2`,
            `xf4`,
            `xf4`
         },
         /* 6 */
         {
            `xu2+2`,
            `xf4`,
            `xf4`
         },
         /* 7 */
         {
            `xu2+2`,
            `xf4`,
            `xf4`
         },
         /* 8 */
         {
            `xu2+2`,
            `xf4`,
            `xf4`
         },
         /* 9 */
         {
            `xu2+2`,
            `xf4`,
            `xf4`
         },
      },
   },

/*********************************************************************/
// Feature name :
// Luma target is used for AEC. These values are the Y value before gamma
// in the linear domain, it includes the result from sensor exposure,
// analog gain, and digital gain.
// Range: 20 to 100.
// Effect: Larger value results in brighter images.
//
/*********************************************************************/

   `xu1`, /* Default Luma Target */
   `xu1+2`, /* Outdoor Luma Target */

/*********************************************************************/
// Feature name :
// Luma tolerance is used in AEC.
// Range: 2 to 8.
// Effect: Larger value results in stable and fast AEC convergence but
//		   the picture brightness is not consistent.
//
/*********************************************************************/

   `xu4`, /* Luma Tolerance */

/*********************************************************************/
// Feature name :
// Exposure index adj step is tied to exposure table. It is 1/(log(step size)).
// 77.9 corresponds to 3% exposure step size.
// We do not recommend the user change this value unless exposure table step size is changed.
/*********************************************************************/

   `xf4`, /* Exposure Index Adj Step */

/*********************************************************************/
// Feature name :
// ISO 100 gain is calibrated by Chromatix tool.
/*********************************************************************/

   `xf4`, /* ISO 100 Gain */

/*********************************************************************/
// Feature name :
// AEC indoor index and outdoor index are used in some dynamic EV related
// features. We recommand not to modify these values.
/*********************************************************************/

   `xu4`, /* AEC Indoor Index */
   `xu4`, /* AEC Outdoor Index */

/*********************************************************************/
// Feature name :
// Max exposure time allowed is defined in seconds. It is used
// for lowlight.
// Effect: Larger value will result in lower noise image but with more blur.
/*********************************************************************/

   `xf4`, /* Max Snapshot Exposure Time Allowed */

/*********************************************************************/
// Feature name :
// AEC aggresiveness determines AEC convergence speed.
// Range: 0 to 1.
// Effect: Higher value results in faster convergence.
/*********************************************************************/

   `xf4`, /* Aggressiveness */

/*********************************************************************/
// Feature name :
// For linear AFR case, Fix FPS AEC Table Index is the last index
// in the exposure table before the frame rate is changed. User should not manually
// change this value, it is determine by Chromatix tool based on exposure table.
// This parameter is not used for non linear AFR case.
/*********************************************************************/

   `xu2+2`, /* Fix FPS AEC Table Index */

/*********************************************************************/
// Feature name :
// High luma region threshold is used for indoor snapshot only as part of dynamic
// EV feature.
// Range: 80 to 255.
// Effect: Lower value tends to avoid over exposure areas for indoor snapshot
//		   pictures.  Setting to 255 will remove the effect of this feature.
/*********************************************************************/

   `xu4`, /* High Luma Region Threshold */

/******************************************************************************/
// Feature name : AEC bright_region
// Feature name : Bright region discrimination.
//  This is a dynamic EV feature for OUTDOOR only, it will increase luma target
//  when there are a large amount very bright areas in the pictures.
// applicale chipset(s): All MSM
// applicable operation mode: Preview and snapshot
//
// variable name: is_supported
// Enables bright region feture.
// default value: 0
// data range: 0 or 1
// constraints: None
// effect: Enables feature.
//
// variable name: reduction
// How bright regions influence will be reduced.
// default value: 0.5
// data range: 0 to 1
// constraints: None
// effect: 1 means bright region will not influence luma calculation. 0 completely
//  discards bright region from luma calculation.
//
// variable name: threshold_LO
// Threshold to compare AEC stats regions when lux_idx is at lux_index_LO.
// default value (calculated): 4 * Default Luma Target
// data range: 0 to 256
// constraints: Must be higher than threshold_HI
// effect: 0 detects all regions as bright, 256 detects none, disable feature.
//  Tends to make image brighter at presence of bright areas.
//
// variable name: lux_index_LO
// Trigger point to calculate thershold used for bright region feature.
//  Pairs with threshold_LO.
// default value (calculated):  AEC outdoor index - 25
// data range: 0 to Max exp table index
// constraints: Higher value than lux_index_HI
// effect: Determines when bright region feature starts to get used.
//
// variable name:threshold_HI
// Threshold to compare AEC stats regions when lux_idx is at lux_index_HI.
// default value (calculated): 2.5 * Default Luma Target
// data range: 0 to 256
// constraints: Lower value than lux_index_LO
// effect: Determines in outdoor type scenes when a region is considered very bright
//  so it can be discarded from luma calculation.
//
// variable name: lux_index_HI
// Trigger point to calculate thershold used for bright region feature.
//  Pairs with threshold_HI.
// default value (calculated): AEC Outdoor Index/2
// data range: 0 to Max exp table index
// constraints: Smaller value than lux_index_LO
// effect: Determines when bright region feature max effect takes place.
//
// variable name: discard_ratio
// Percent of regions' biases that may be modified by bright region.
// default value: 0.5
// data range: 0 to 0.5
// constraints: 0 disbles feature.  Algorithm caps at 0.5,
// effect: 0 disables feature, higher value allowes more regions to get discarded
//  from luma calculation.
/******************************************************************************/

   /* AEC Bright Region */
   {
      `xu4`, /* Is Supported? */
      `xf4`, /* Reduction */
      `xu4`, /* Threshold Low */
      `xu4`, /* Lux Index Low */
      `xu4`, /* Threshold High */
      `xu4`, /* Lux Index High */
      `xf4`, /* Discard Ratio */
   },

/******************************************************************************/
// Feature name : AEC dark_region
// Feature name : Dark region discrimination .
//  This is a dynamic EV feature for indoor and outdoor, it will decrease luma target when there
//  are a large amount very dark areas in the pictures. It applies to both viewfinder and snapshot.
// applicale chipset(s):All MSM
// applicable operation mode: Preview and snapshot
//
// variable name: is_supported
// Enables feature.
// default value: 0
// data range: 0 and 1
// constraints: none
// effect: Detects regions that are dark and reduces their effect on luma
//  calculation.
//
// variable name: threshold_LO
// Any region below this brightness
//  value will be not used for luma calculation.
// default value: 0.1
// data range: 0 to 0.1
// constraints: None
// effect: Lower Value reduces impact of feature. Tend to make image darker
//  in presence of dark and bright objects in the scene.
//
// variable name:threshold_HI
// Any region above this brightness
//  value will be not used for luma calculation.
// default value: 0.5
// data range: 0 to 0.8
// constraints: None
// effect: Higher value increases effect of dark region feature. Tend to make
//  image darker in presence of dark and bright objects in the scene.
//
// variable name: discard_ratio
// Percent of regions' biases that may be modified by bright region.
// default value: 0.5
// data range: 0 to 0.5
// constraints: None
// effect: 0 disables the feature.
/******************************************************************************/

   /* AEC Dark Region */
   {
      `xu4`, /* Is Supported? */
      `xf4`, /* Threshold Low */
      `xf4`, /* Threshold Hi */
      `xf4`, /* Discard Ratio */
   },

/******************************************************************************/
// Feature name : AEC LED
// variable name: wled_trigger_idx
// Lux index when LED strobe will start to
//  be used.  Anytime lux-idx is higher than this, it will flag for LED usage.
// applicale chipset(s): All MSM
// applicable operation mode: Preview and snapshot.
// default value (calculated) : Max Exposure Table Index-1
// data range: 0 to max lux_idx
// constraints: None
// effect: 0 will always make LED strobe to be used. Larger value requires scene
//  to be darker to LED to be used.
/******************************************************************************/

   `xu2+2`, /* wLED Trigger Index */

/******************************************************************************/
// Feature name : AEC LED
// variable name: aec_led_preview_flux
// Amount of light flux emitted by LED in preview.
// applicale chipset(s): All MSM
// applicable operation mode: Preview
// default value: 1
// data range: Any positive number
// constraints: None
// effect: Ratio between aec_led_preview_flux and aec_led_snapshot_flux determines
//  AEC compensation to be used.
/******************************************************************************/

   `xf4`, /* AEC LED Preview Flux */

/******************************************************************************/
// Feature name : AEC LED
// applicale chipset(s):All
// applicable operation mode:Snapshot
//
// variable name: aec_led_snapshot_flux_hi
// Sets LED flux output at highest current
//  mode.  LED power to be used is determined by available power on battery
//  for this feature, which is customizable by OEM.
// default value: 4.0
// data range: 1.0 to 1000
// constraints: Positive number
// effect: Higher values means LED outputs more lumen.  If brighter image is
//  needed, make this value smaller, for darker image make value higher.
//
// variable name: aec_led_snapshot_flux_med
// Sets LED flux output at medium current
//  mode. LED power to be used is determined by available power on battery
//  for this feature, which is customizable by OEM.
// default value: 1.0
// data range: 1.0 to 1000
// constraints: Positive number
// effect: Higher values means LED outputs more lumen.  If brighter image is
//  needed, make this value smaller, for darker image make value higher.
//
// variable name: aec_led_snapshot_flux_low
// Sets LED flux output at low current
//  mode. LED power to be used is determined by available power on battery
//  for this feature, which is customizable by OEM.
// default value: 1.0
// data range: 1.0 to 1000
// constraints: Positive number
// effect: Higher values means LED outputs more lumen.  If brighter image is
//  needed, make this value smaller, for darker image make value higher.
/******************************************************************************/

   `xf4`, /* AEC LED Snapshot Flux Hi */
   `xf4`, /* AEC LED Snapshot Flux Med */
   `xf4`, /* AEC LED Snapshot Flux Low */

/******************************************************************************/
// Feature name : AEC Motion ISO
// applicale chipset(s):All MSM
// applicable operation mode: snapshot, preview, and video
// (Defaults are same for all 3 modes)
//
// variable name: motion_iso_enable
// motion_iso_enable
// default value: 0
// data range: 0 or 1
// constraints: None
// effect: Enables motion ISO feature. while scenes are changing or moving,
//  higher AE gains are used in efforts to reduce motion blur.
//
// variable name: motion_iso_aggressiveness
// Determines how fast motion effect is applied
//  to preview and snapshot.  Higher values cause gains to react rapidly upon any
//  motion detection.
// default value: 0.5
// data range: 0.01 to 1
// constraints: None
// effect: Lower value makes motion to take longer to affect gains and exposure
//  times and also longer to dissipate.
//
// variable name: motion_iso_threshold
// Motion metric caclulated by algorithm
// is compared to this threshold, if higher thant motion ISO is applied.
// default value: 40
// data range: Any positive value.
// constraints: Depending on sensor noise, this threshold needs to be adjusted
//   to make sure sensor noise is not triggering motion iso.  Value also needs
//   be adjusted based on 256 or 64 AE stats region mode used.
// effect: Lower value trigger motion ISO sooner.  Higher value requires
//  more scene motion to trigger feature.
//
// variable name:motion_iso_max_gain
// Max gain allowed to be used when motion ISO feature is triggered.
// default value (calculated):  2 *  Max Exposure Table Gain.
// data range: max AEC table gain to max gain supported by system.
// constraints: If this value is set to default normal mode max gain, motion
//  ISO will have no effect in low light.
// effect: Higher gains allow more Motion ISO effect for low light scenes.
//  Expect higher noise due to high gains used.
/******************************************************************************/

   /* Motion ISO */
   {
      `xu4`, /* Enable */
      `xf4`, /* Aggressiveness */
      `xf4`, /* Threshold */
      `xf4`, /* Max Gain */
   },

/******************************************************************************/
// Feature name : camcorder aec convergence
// variable name: aec_holding_time_adj
// Adjust camcorder aec convergence.
// applicale chipset(s): all MSM
// applicable operation mode: camcorder preview/recording
// default value: 0
// data range: -10 to 10
// constraints: none
// effect: larger value, longer holding time. Negative number, shorter holding time
/******************************************************************************/

   `xu4`, /* Convergence Holding Time Adjust */

/*********************************************************************/
// Feature name :
// The following framerate information should reflect the sensor driver setting.
// They should be in sync with the sensor driver capability. Forcefully
// changing their values will NOT actually change the frame, instead it may
// cause issues with internal alogirhms that use this information as input.
/*********************************************************************/

   `xf4`, /* Max Video FPS */

/******************************************************************************/
// variable name: max_sensitivity_lux_index
// Max lux_index when luma target is able to be reached.
// applicable chipset:  all chipsets
// 3A version: N/A
// applicable operation mode: preview and snapshot
// default Value (calculated) : Max Exposure Table Index
// Data Range: 0 to 1000
// constraints: none
// effect: we do not set this value, it is a value determined by exp table
//         and supported FPS.
// Other info: Currently linear AFR case is used. For non-linear AFR case, default is
//                max_exp_index + (Num_FPS-1)*(max_FPS/min_FPS)*23
/******************************************************************************/

   `xu2+2`, /* Max Sensitivity Lux Index */

/******************************************************************************/
// variable name: AEC_weight_center_weighted
// Weight for each AEC STATs region under center weighted mode
// applicable chipset:  all chipsets
// 3A version: N/A
// applicable operation mode: preview and snapshot
// default Value:
// Data Range: N/A
// constraints: none
// effect: region with higher weight value has more influence to AEC.
/******************************************************************************/

   /* Center Weighted */
   {
      {
		`xf4a16`
      },
      {
		`xf4a16`
      },
      {
		`xf4a16`
      },
      {
		`xf4a16`
      },
      {
		`xf4a16`
      },
      {
		`xf4a16`
      },
      {
		`xf4a16`
      },
      {
		`xf4a16`
      },
      {
		`xf4a16`
      },
      {
		`xf4a16`
      },
      {
		`xf4a16`
      },
      {
		`xf4a16`
      },
      {
		`xf4a16`
      },
      {
		`xf4a16`
      },
      {
		`xf4a16`
      },
      {
		`xf4a16`
      },
   },

/******************************************************************************/
// variable name: AEC_weight_spot_weighted
// Weight for each AEC STATs region under spot weighted mode
// applicable chipset:  all chipsets
// 3A version: N/A
// applicable operation mode: preview and snapshot
// default Value:
// Data Range: N/A
// constraints: none
// effect: region with higher weight value has more influence to AEC.
/******************************************************************************/

   /* Spot Weighted */
   {
      {
         `xf4a16`
      },
      {
         `xf4a16`
      },
      {
         `xf4a16`
      },
      {
         `xf4a16`
      },
      {
         `xf4a16`
      },
      {
         `xf4a16`
      },
      {
         `xf4a16`
      },
      {
         `xf4a16`
      },
      {
         `xf4a16`
      },
      {
         `xf4a16`
      },
      {
         `xf4a16`
      },
      {
         `xf4a16`
      },
      {
         `xf4a16`
      },
      {
         `xf4a16`
      },
      {
         `xf4a16`
      },
      {
         `xf4a16`
      },
   },
   /* Strobe Flash */
   {

/******************************************************************************/
// Feature name: AEC strobe flash estimation.
// Applicable chipset:  7k and newer supporting strobe flash and precision timers.
// 3A version: 2.1
// Applicable operation mode: Viewfinder and snapshot.
//
// Variable name: strobe_flash_enable.
// 1 (TRUE) uses strobe flash estimation,
// 0 (FALSE) no flash estimation used for AEC.
// Default value: 0.
// Data range: 0 or 1.
// Constraints: None.
//
// Variable name: strobe_min_time.
// Preflash strobe trigger time used. Also minimum strobe trigger
//  time (microseconds scale) used for snapshot.
// Default value: 10.
// Data range: 5 or 1000  (0us to 1ms).
// Constraints: Need to verify that strobe capacitor is not discharged too much
//              so rest of charge can be used for snapshot capture.
// Effect: Some strobes require specify minimum strobe trigger time. If made
//         shorter then strobe intensity is not consistent from flash to flash
//         or strobe will not fire.
//
// Variable name: intersect_time_gain.
// Trigger time where strobe output light gain starts to
//  compress with respect to trigger time.
// Default value: 7.
// Data range: 1 to 20.
// Constraints: None.
//
// Variable name: post_intersect_strobe_flux_rate_increase.
// After compression point determined by trigger time set in
//  intersect_time_gain, this value specifies the
//  trigger time increment for each 1x strobe light flux gain increment.
// Default value: 138.
// Data range: 1 to 1000 in us.
// Constraints: None.
//
// Variable name: max_strobe_gain.
// Max strobe gain available.
// Default Value: 8.
// Data Range: 1 to 20.
// Constraints: None.
// Effect: If value is too high, AWB may be wrong when strobe and ambient
//  illuminants are mixed and scene is far such that strobe has little effect.
//  AEC may show underexposed if value is higher than strobe is capable of.
//
// Variable name: strobe_flash_lux_idx_trigger.
// When lux index is larger than this value
//   Xenon strobe will be used if full frame exposure for snapshot contraint
//   is met.
// Default value (calculated) :  AEC Indoor Index + 46.
// Data range: 0 to 1000.
// Constraints: Lux_idx trigger may be met but if exposure time condition is
//   not met, then flash won't be used.
// Effect: Larger value will require scene to be darker for strobe to be used.
/******************************************************************************/

      `xu4`, /* Enable */
      `xu4`, /* Min Time */
      `xf4`, /* Intersect Time Gain */
      `xf4`, /* Post Intersect Flux Rate Incrase */
      `xf4`, /* Max Gain */
      `xu4`, /* Lux Idx Trigger */
   },
   /* Touch */
   {

/******************************************************************************/
// Feature name : Touch AEC  3A 2.2
// applicable chipset:  8k, 7x30 and newer.
// 3A version : 2.2.
// applicable operation mode: View finder and snapshot.
//
// variable name: touch_roi_enable
// 1 (TRUE) enables the feature, 0 (FALSE) disables the feature.
// default Value: 1
// Data Range: 0 or 1
// constraints:
// effect: 1 (TRUE) enables the feature, 0 (FALSE) disables the feature.
//
// variable name: touch_roi_weight
// Determines influence or weight of UI (touch) area vs. normal
//  AEC metering mode.
// default Value: 0.8
// Data Range: 0 to 1
// constraints:
// effect: 0 means no influence form UI selected area, 1 means "spot meter" on
//         area selected.  0.5 means both selected area luma and normal AEC luma
//         are averaged.
/******************************************************************************/

      `xu4`, /* ROI Enable */
      `xf4`, /* Weight */
   },
   /* Face */
   {

/******************************************************************************/
// Feature name : Face priority AEC, 3A 2.2
// applicable chipset:  7k and newer supporting face detection and interface
//                      with auto exposure.
// 3A version: 2.2
// applicable operation mode: View finder and snapshot.
//
// variable name: aec_face_enable
// 1 (TRUE) enables the feature, 0 (FALSE) disables the feature.
// default Value: 0
// Data Range: 0 or 1
// constraints:
// effect:
//
// variable name: aec_face_weight
// Determines how much face area contributes for frame luma calculation.
// default Value: 0.8
// Data Range: 0 to 1
// constraints:
// effect: 1 means all influence comes from face area.  0 means face information
// has no influence on AEC.
//
// variable name: dark_skin_ratio
// Skin luma vs. white point luma ratio if close to this value
//  then we set flag face as dark skin.
// default Value: 0.3
// Data Range: 0 to 1
// constraints:
// effect:
//
// variable name: light_skin_ratio
// Skin luma vs. white point luma ratio if close to this value
//  then we flag face as light skin.
// default Value: 0.7
// Data Range: 0 to 1
// constraints:
// effect:
//
// variable name: dark_skin_luma_target
// Desired luma for dark skin face.
// default Value (calculated): Default Luma Target * 0.8
// Data Range: 0 to 255
// constraints: To be applied post UI EV udpates.
// effect: AEC tries to make a dark face luma achieve this target.
//
// variable name: light_skin_luma_target
// Desiored luma for light skin face.
// default Value (calculated): Default Luma Target * 1.2
// Data Range: 0 to 255
// constraints: To be applied post UI EV udpates.
// effect: AEC tries to make a light face luma achieve this target.
/******************************************************************************/

      `xu4`, /* Enable */
      `xf4`, /* Weight */
      `xf4`, /* Dark Skin Ratio */
      `xf4`, /* Light Skin Ratio */
      `xu4`, /* Dark Skin Luma Target */
      `xu4`, /* Light Skin Luma Target */
   },

/******************************************************************************/
// Feature name: Fast Convergence AEC for camera.
// Applicable chipset(s): VFE 3.1 and later with Bayer support.
// Applicable operation mode:  Camera mode only.
//
// Variable name: aec_fast_convergence_skip.
// Frames to skip between exposure updates.
// Default value:  2.
// Data range: 1 to 5.
// Constraints: If exposure updates happen before previous frame exposure
//  updates are reflected on stats, aec oscillation may be present.  Increasing
//  aec_fast_convergence_skip will remove the problem.
// Effect: Larger values will slow down aec convergence, smaller values will
//  converge faster but may cause instability if i2c and sensor updates are
//  slow.
//
// variable name: aec_slow_convergence_skip.
// Frames to skip between exposure updates.
// Default value:  1.
// Data range: 1 to 5.
// Constraints: If exposure updates happen before previous frame exposure
//  updates are reflected on stats, aec oscillation may be present.  Increasing
//  aec_slow_convergence_skip will remove the problem.
// Effect: Larger values will slow down aec convergence, smaller values will
//  converge faster but may cause instability if i2c and sensor updates are
//  slow.
/******************************************************************************/

   `xu4`, /* AEC Fast Convergence Skip */
   `xu4`, /* AEC Slow Convergence Skip */
   /* Bayer Stats Config */
   {

/******************************************************************************/
// Feature name: Bayer Stat AEC.
// Applicable chipset(s): VFE 3.2 and later with bayer grid stats support.
// Applicable operation mode:  Preview, camcorder modes and ZSL.
//
// Variable name: bright_region_influence_adj_enable.
// Enables and disables bright region weight modification or influence
//   reduction, as bright region discrimination.
// Default value:  1.
// Data range: 0 and 1.
// Constraints: None.
// Effect: 1 enabled, 0 is disabled.
//
// Variable name: bright_weight_lux_idx_trigger.
// lux index at which to start applying different weighting to regions
//   flagged as bright.
// Default value (calculated):  Indoor_index + 60
// Data range: Indoor_index to 255
// Constraints: None.
// Effect: Defines the scene brightness range where this features works.
//
// Variable name: bright_weight_def.
// Weight to be applied on region flagged as bright for overall frame
//   luma calculation
// Default value:  0.5
// Data range: 0 to 1.0
// Constraints: None.
// Effect: 1.0 weight disables this option, i.e. all bright regions weight won't
//   be modified.  Setting 0 will make bright regions not contribute to frame
//   luma calculation.
//
// Variable name: bright_level.
// Regions above this level are flagged as bright regions.
// Default value:  220.
// Data range: 2*default_luma_target to 255.
// Constraints: None.
// Effect: 255 disables the feature as no pixel in 8 bit domain can go above 255.
//   Setting value too low will tend to flag more regions as bright.
//
// Variable name: color_based_metering_enable.
// Enables and disables color information used by AEC.
// Default value:  1.
// Data range: 0 and 1.
// Constraints: None.
// Effect: 1 enables the option to use color in AEC metering, histogram luma
//   biasing.  If disabled, portions of AEC that need color information will
//   not execute.
//
// Variable name: col_sat_weight.
// Option to apply different weight to flagged extreme color regions.
// Default value:  1.0
// Data range: 0 to 1.0
// Constraints: None.
// Effect: 1.0 disables the option as colorful regions get same weight applied.
//   0 means that a region flagged as colorful will not be used for frame luma
//   calculation.
//
// Variable name: color_luma_decrease_ratio.
// Option to lower the expected luma for flagged extreme color regions.
// Default value:  2.0
// Data range: 1.0 to 2.0
// Constraints: None.
// Effect: 1.0 disables the option as colorful regions do not get their luma
//   modified.  2.0 means that their measured luma is doubled such that it will
//   tend to make colorful regions darker after aec converges.
//
// Variable name: rg_ratio_lth.
// Lower threshold for r/g response of the region, in use with
//   bg_ratio_lth to detect extreme green regions.
// Default value:  0.85
// Data range: 0 to 1.0
// Constraints: None.
// Effect: If set too high, regions will be easier detect as extreme green color. If set
//   too low, it will be harder to detect extreme green regions.
//
// Variable name: rg_ratio_hth.
// Upper threshold for r/g response of the region.
// Default value:  2.2
// Data range: 1.0 to 4.0
// Constraints: None.
// Effect: If set too low, regions will be easier detect as extreme red color, if set
//    too high it will be harder to detect extreme red regions.
//
// Variable name: bg_ratio_lth.
// Lower threshold for b/g response of the region, in use with rg_ratio_lth to detect
//    extreme green regions.
// Default value:  0.6
// Data range: 0 to 1.0
// Constraints: None.
// Effect: If set too high, regions will be easier detect as extreme green color. If set
//   too low, it will be harder to detect extreme green regions.
//
// Variable name: bg_ratio_hth.
// Upper threshold for b/g response of the region, used to detect extreme blue regions.
// Default value:  1.8
// Data range: 1.0 to 4.0
// Constraints: None.
// Effect: If set too low, regions will be easier detect as extreme blue color regions, if set
//    too high it will be harder to detect extreme blue regions.
//
// Variable name: flat_white_grey_vs_nongrey_th.
// Threshold to determine if flat area is brighter than colored regions:
//    if (near_gr_luma > th * non_gr_luma) make overall
//    frame brighter, i.e. increase exposure.
// Default value:  1.1
// Data range: 1.05 to 2.0
// Constraints: None.
// Effect: If set too low, background will be too easy to detect as white or
//    brighter than overall scene causing tendency to increase exposure for
//    flat scenes.
//
// Variable name: flat_dark_grey_vs_nongrey_th.
// Threshold todetermine if flat area is darker than colored regions:
//    if (near_gr_luma < th*non_gr_luma) lower exposure.
// Default value:  0.5
// Data range: 0.9 to 0
// Constraints: None.
// Effect: If set too low, makes it harder to detect flat areas as dark, if set
//   too high, it will make it easier to detect flat areas as dark and tend
//   to reduce exposure on flat scenes.
//
// Variable name: hist_ent_enable.
// Enable and disable histogram frame luma offset feature.
// Default value:  1.
// Data range: o and 1.
// Constraints: None.
// Effect: 0 disabled the feature, 1 enables the feature.
//
// Variable name: hist_weight_table.
// LUT to define weight vs. pixel level bin to perform histogram analysis.
// Default value:  LUT.
// Data range: LUT.
// Constraints: None.
// Effect: By applying different weight vs. pixel level, the histogram analysis
//   may bias luma target to reduce those histogram bins with lower weight.
//
// Variable name: luma_target_reset_ratio.
// Tolerance to determine is scene changed enough to reset histogram LT offset to 0.
// Default value:  3.
// Data range: 1 to 10.
// Constraints: None.
// Effect: Higher value allows more tolerance, i.e. making scene change detection
//  less sensitivie for histogram LT offset resetting.
//
// Variable name: hist_luma_target_adjusment_cap.
// Limits the extent of luma target adjustment done by histogram analysis.
//   Example: 2 is Luma Target can be doubled, and Luma Target can be halved by
//   feature.
// Default value:  2.0
// Data range: 0 to 100.
// Constraints: None.
// Effect: If made 0 feature is disabled.  Higher values allow more modification
//   of luma target by the histogram analysis.
//
// Variable name: near_grey_tolerance.
// Region R/G and B/G tolerance to flag region as near grey.
// Default value:  0.05
// Data range: 0 to 1.0
// Constraints: None.
// Effect: Larger tolerances allow more regions to be detected as near grey for
//   flat scene dark vs. bright flat area detection.  If too large, very few color
//   regions will be detected.
//
// Variable name: bright_flat_compensation_ratio.
// Determines how much luma will be adjusted
//  for bright flat scene detection after all conditions are met
//  luma = luma * bright_flat_compensation_ratio ==> temporal filter used
// Default value:  0.6
// Data range: 0.5 to 1.0
// Constraints: None.
// Effect: Value of 1.0 will not affect luma when bright flat scene is detected.
//  Value of 0.5 will halve luma causing the overall exposure to double, i.e.,
//  final image is brighter.
//
// Variable name: dark_flat_compensation_ratio.
// Determines how much luma will be adjusted
//  for dark flat scene detection after all conditions are met
//  luma = luma * dark_flat_compensation_ratio ==> temporal filter used.
// Default value:  1.8
// Data range: 1.0 to 2.0
// Constraints: None.
// Effect: Value of 1.0 will not affect luma when dark flat scene is detected.
//  Value of 2.0 will double luma causing the overall exposure to be cut in half,
//  i.e., final image is darker.
/*******************************************************************************/

      `xu4`, /* Bright Region Influence ADJ Enable */
      `xu4`, /* Bright Weight Lux Index Trigger */
      `xf4`, /* Bright Weight Def */
      `xu4`, /* Bright Level */
      `xu4`, /* Color-Based Metering Enable */
      `xf4`, /* Color Saturated Weight */
      `xf4`, /* Color Luma Decrease Ratio */
      `xf4`, /* RG Ratio lth */
      `xf4`, /* RG Ratio hth */
      `xf4`, /* BG Ratio lth */
      `xf4`, /* BG Ratio hth */
      `xf4`, /* Flat White Gray vs Nongray Thresh */
      `xf4`, /* Flat Dark Gray vs Nongray Thresh */

/******************************************************************************/
// Feature name: Histogram pixel level weighting.
// Applicale chipset(s): VFE 3.2 and later with bayer grid stats support.
// Applicable operation mode:  Preview, camcorder modes and ZSL.
//
// Variable name: pixel_value.
// Determines the weight for the specified pixel level in this LUT.
// Default value:  0.
// Data range: 0 to 255.
// Constraints: None.
// Effect: Sets the weight for this pixel level bin in the histogram analysis.
//
// Variable name: weight.
// Determines the weight for the specified pixel level in this LUT.
// Default value:  1.
// Data range: 0 to 1.
// Constraints: None.
// Effect: Sets the weight corresponding to pixel bin in the histogram analysis.
//         Lower value means histogram luma target biasing will try to reduce
//         this pixel bin.
/*******************************************************************************/

      `xu4`, /* Hist ENT Enable */
      /* Hist Weight Table */
      {
         /* Entry 0 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 1 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 2 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 3 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 4 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 5 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 6 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 7 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 8 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 9 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 10 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 11 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 12 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 13 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 14 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 15 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 16 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 17 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 18 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
         /* Entry 19 */
         {
            `xu4`, /* Pixel Value */
            `xf4`, /* Weight */
         },
      },
      `xf4`, /* Luma Target Reset Ratio */
      `xf4`, /* Hist Luma Target Adj Cap */
      `xf4`, /* Near Gray Tolerance */
      /* Hist Flat Detector */
      {

/******************************************************************************/
// Feature name: Bayer Grid Stat Histogram Flat Detector.
// Applicable chipset(s): VFE 3.2 and later with bayer grid stats support 3A 4.0
// Applicable operation mode:  Preview, camcorder modes and ZSL.
//
// Variable name: hist_flat_detector_enable.
// Flag to enable and disable flat scene detection.
// Default value:  1.
// Data range: 0 and 1.
// Constraints: None.
// Effect: 0 disables the flat scene detection, 1 enables flat scene detection.
//
// Variable name: start_level.
// Pixel level to start checking the histogram for flat scene.
// Default value (calculated):  42.
// Data range: range+1 to end_level-range.
// Constraints: None.
// Effect: If setting is too low, it will detect a 0 lux image as a flat image.
//
// Variable name: end_level.
// Pixel level to end checking the histogram for flat scene.
// Default value:  200.
// Data range: 255-range to 255.
// Constraints: None.
// Effect: If setting is too high, it could potentially detect saturated pixels
//   as a flat image. This is not likely to happen since AEC will bring luma down.
//
// Variable name: range.
// Pixel level range on which to check percent of pixel content.
// Default value:  40.
// Data range: 20 to 60.
// Constraints: None.
// Effect: If setting is too high, it will make it easier to detect flat scenes
//   but may wrongly detect even if not flat.  If set too low, it may not detect
//   flat scenes.
//
// Variable name: delta_th.
// If the percentage of number of pixels within the range is larger
//   than this threshold, the scene is flagged as flat.
// Default Value:  0.75.
// Data range: 0.5 to 0.9
// Constraints: None.
// Effect: If setting is too high, it will make it harder to detect flat scenes
//  or may not detect at all due to roll-off gradient.  If set too low, it may
//  falsely detect flat scenes that are not.
//
// Variable name: bright_flat_det_th.
// Describes by how much number of pixels
//   in dark tail of histogram should be greater than number of pixels in
//   bright tail of histogram
// Default value:  1.2
// Data range:  1.0 to 1.5
// Constraints:  None.
// Effect: Lower value makes it easier to detect bright flat field, a value
//   of 1.0 means that dark tail number of pixels can be greater or equal to
//   number of pixels in bright tail and still be considered bright flat
//   field.  A value of 1.5 means if condition below happens, it may be
//   considered bright field (if rest of conditions are met also)
//   dark_flat_tail_numpix > 1.5 * bright_flat_tail_numpix
//
// Variable name: dark_flat_det_th.
// Describes by how much number of pixels in bright tail of histogram
//   should be greater than number of pixels in dark tail of histogram.
// Default value:  10.0
// Data range:  1.0 to 20.0
// Constraints:  None.
// Effect: Lower value makes it easier to detect dark flat field. This value
//   means that there has to be dark_flat_det_th more pixels in the bright tail
//   than in the dark tail of the histogram.
//
// Variable name: bright_flat_tail_det.
// Defines minimum amount of pixels need to be in dark tail vs. total
//   pixels in image to be called a bright flat scene.
// Default value: 0.001
// Data range:  0.0005 to 0.01
// Constraints:  None.
// Effect: Higher value makes it harder to detect bright flat field as more
//   pixels are needed in the dark tail vs. total amount of pixels.
//
// Variable name: dark_flat_tail_det.
// Defines minimum amount of pixels needed to be in the bright tail vs.
//   total pixels in the image to be called a dark flat scene.
// Default value: 0.10
// Data range:  0.05 to 0.20
// Constraints: None.
// Effect: Higher value makes it harder to detect as dark flat field since more
//  pixels are needed in the bright tail vs. total amount of pixels in the image.
/*******************************************************************************/

         `xu4`, /* Enable */
         `xu4`, /* Start Level */
         `xu4`, /* End Level */
         `xu4`, /* Range */
         `xf4`, /* Delta Threshold */
         `xf4`, /* Bright Flat Det Th */
         `xf4`, /* Dark Flat Det Th */
         `xf4`, /* Bright Flat Tail Det */
         `xf4`, /* Dark Flat Tail Det */
      },
      `xf4`, /* Bright Flat Compensation Ratio */
      `xf4`, /* Dark Flat Compensation Ratio */
   },

/******************************************************************************/
// Feature name: Shake Detection/Indicator for Snapshot and ZSL.
//
// Variable name: Enable.
// Enables or disables the feature.
// Default value:  N/A.
// Data range: 0 to 1.
// Constraints: None.
// Effect: 0 disables the feature, 1 enables the feature.
//
// Variable name: valid_entries.
// Entries to be used from the LUT.
// Default value:  2.
// Data range: 2 to 10.
// Constraints: None
// Effect: Larger number of entries provide finer control over shake thresholds
//    vs. exposure time.
//
// Variable name: shake_table.
// LUT to defining the trade-off between
//   the motion metric and the exposure time to flag the images as containing
//   camera shake, moderate shake or no shake.
// Default value:  N/A.
// Data range: N/A.
// Constraints: None.
// Effect: N/A.
//
// Variable name: exposure_time.
// Indicator for exposure time in the LUT.
// Default value:  N/A
// Data range: 0.1ms to 1000ms.
// Constraints: Has to be increasing with LUT index.
// Effect: At this exposure time, the shake threshold specified is used.
//
// Variable name: no_shake_threshold.
// Shake value is compared to this
//   threshold to determine if the camera is shaking or not.
// Default value:  N/A.
// Data range: 10.
// Constraints: Has to be decreased with LUT index.
// Effect: At a given exposure time, the shake threshold specified is used to
//   determine if the phone is shaking during capture.
//
// Variable name: moderate_shake_threshold.
// Shake value is compared to this
//   threshold to determine if the camera is shaking or not.
// Default value:  N/A.
// Data range: 10.
// Constraints: Has to be higher than no_shake_threshold and increasing
//    with LUT index.
// Effect: At a given exposure time, the shake threshold specified is used to
//   determine if the phone is shaking during capture.
/******************************************************************************/

   /* Shake Detection */
   {
      `xu4`, /* Enable */
      `xu1+3`, /* Valid Entries */
      {
         /* Entry 0 */
         {
            `xf4`, /* Exposure Time */
            `xf4`, /* No Shake Threshold */
            `xf4`, /* Moderate Shake Threshold */
         },
         /* Entry 1 */
         {
            `xf4`, /* Exposure Time */
            `xf4`, /* No Shake Threshold */
            `xf4`, /* Moderate Shake Threshold */
         },
         /* Entry 2 */
         {
            `xf4`, /* Exposure Time */
            `xf4`, /* No Shake Threshold */
            `xf4`, /* Moderate Shake Threshold */
         },
         /* Entry 3 */
         {
            `xf4`, /* Exposure Time */
            `xf4`, /* No Shake Threshold */
            `xf4`, /* Moderate Shake Threshold */
         },
         /* Entry 4 */
         {
            `xf4`, /* Exposure Time */
            `xf4`, /* No Shake Threshold */
            `xf4`, /* Moderate Shake Threshold */
         },
         /* Entry 5 */
         {
            `xf4`, /* Exposure Time */
            `xf4`, /* No Shake Threshold */
            `xf4`, /* Moderate Shake Threshold */
         },
         /* Entry 6 */
         {
            `xf4`, /* Exposure Time */
            `xf4`, /* No Shake Threshold */
            `xf4`, /* Moderate Shake Threshold */
         },
         /* Entry 7 */
         {
            `xf4`, /* Exposure Time */
            `xf4`, /* No Shake Threshold */
            `xf4`, /* Moderate Shake Threshold */
         },
         /* Entry 8 */
         {
            `xf4`, /* Exposure Time */
            `xf4`, /* No Shake Threshold */
            `xf4`, /* Moderate Shake Threshold */
         },
         /* Entry 9 */
         {
            `xf4`, /* Exposure Time */
            `xf4`, /* No Shake Threshold */
            `xf4`, /* Moderate Shake Threshold */
         },
      },
   },
   /* Red Eye Reduction */
   {

/******************************************************************************/
// Feature name: Red eye reduction
// Applicable chipset(s): VFE 3.1 and later with Bayer support.
// Applicable operation mode:  Camera mode only.
//
// Variable name: red_eye_reduction_xenon_strobe_enable.
// Enables and disables the STROBE red-eye reduction feature.
// Default value:  0.
// Data range: 0 to 1.
// Constraints: Dependent on h/w availability of strobe unit.
// Effect: 0 disables the feature; 1 enables the feature.
//
// Variable name: red_eye_reduction_led_flash_enable.
// Enables and disables the LED red-eye reduction feature.
// Default value:  0.
// Data range: 0 to 1.
// Constraints: Dependent on h/w availability of LED unit.
// Effect: 0 disables the feature; 1 enables the feature.
//
// Variable name: number_of_preflash_cycles.
// Number of preflashes to trigger
//  prior to snapshot flash and capture.  Recommend for LED to use
//  a single longer duration cycle since it is typically not connected
//  to precision timers.
// Default value:  3.
// Data range: 0 to 20.
// Constraints: None.
// Effect: Number of preflashes.
//
// Variable name: preflash_interval_between_pulses.
// Time to wait between preflash triggers.  Unit is is millisecond (ms).
// Default value:  15.
// Data range: 0 to 33.
// Constraints: Larger than preflash pulse duration.
// Effect: Larger values is more time between pre-flashes.
//
// Variable name: preflash_xenon_pulse_duration.
// Trigger duration for strobe type pre-flash.  Unit is is microsecond (us).
// Default value:  10.
// Data range: 0 to 20.
// Constraints: Larger values may cause strobe charge in cap to deplete and
//              not have enough light output for final snapshot capture.
// Effect: Larger value is brighter pre-flash intensity.
//
// Variable name: preflash_LED_pulse_duration.
// LED on duration for LED type pre-flash.  Unit is is millisecond (ms).
// Default value:  100.
// Data range: 0 to 1000.
// Constraints: Larger values may cause LED to overheat.  Verify LED unit
//              data sheet for heat disipation requirements.
// Effect: Larger value is longer LED preflash duration.
//
// Variable name: preflash_LED_current.
// Preflash current to be used for driving the LED preflashes.  Unit is mA.
// Default value:  100.
// Data range: 0 to 1000.
// Constraints: Larger values may cause LED to overheat.  Verify LED unit
//              data sheet for heat disipation requirements.
//              S/W implementation may only support discrete current values, in
//              that case, LED current will go to nearest lower value to this
//              setting.
// Effect: Larger value is brighter LED preflash intensity.
/******************************************************************************/

      `xu4`, /* Xenon Strobe Enable */
      `xu4`, /* LED Flash Enable */
      `xu4`, /* Number of Preflash Cycles */
      `xu4`, /* Preflash Interval Between Pulses */
      `xu4`, /* Preflash Xenon Pulse Duration */
      `xu4`, /* Preflash LED Pulse Duration */
      `xu4`, /* Preflash LED Current */
   },
},

/******************************************************************************/
// Feature name: auto flicker detection.
// Parameters used for AFD algorithm.
// Applicable chipset(s): MSM7xxx and QSD8xxx.
// Applicable operation mode: VF.
//
// Variable name: AFD_continuous_enable
// Used to determine if run continuous AFD
// Default value: 0.
// Data range: 0 or 1.
// Constraints:
// Effect: 1 means AFD is continuous run periodically, 0 means only run once at camera startup.
//
// Variable name: chromatix_auto_flicker_detection_data_type.afd_std_threshold
// Used to determine if a periodic pattern is present. We measure the distance
//    between adjacent peaks and if the standard deviation of these distances is
//    smaller than the afd_std_threshold  value, it has periodic pattern,
//    ie. flicker detect flag is set.  This is part of the multi-peak algorithm.
// Default value: 0.15
// Data range:
// Constraints:
// Effect: We do not recommend the user change this parameter.
//
// Variable name: chromatix_auto_flicker_detection_data_type.afd_percent_threshold
// Used by the single peak algorithm only, which is under zoom.
//    The entire single peak algorithm is not needed if we are getting the row-sum stats from VFE HW.
//    Therefore, this parameter is only used for SW AFD solution.
//    Four frames (4 = AFD_NUM_FRAMES  AFD_FRAME_SKIP  1)
//    must have a peak present.  For flicker to be detected, the percentage of peak leading and
//    falling edges must be larger than this percentage.
// Default value: 50.
// Data range:
// Constraints:
// Effect: We do not recommend the user change this parameter.
//
// Variable name: chromatix_auto_flicker_detection_data_type.afd_diff_threshold
// Filtered Peak (diff between neighboring frames) value must be above this threshold to be considered a valid peak,
//    otherwise it is considered noise and is ignored.  When the view finder
//    window changes size, the threshold value should also be tuned.
//    The reason has to do with row sums are not calculated for every row but every other.
//    Tuning consists of finding a threshold value that detects the valid peaks while rejecting noise.
// Default value: 90.
// Data range:
// Constraints:
// Effect: We do not recommend the user change this parameter.
//
// Variable Name: chromatix_auto_flicker_detection_data_type.afd_frame_ct_threshold
// Determines if the AFD process should start, afd_frame_ct_threshold
//    number of frames are skipped before commencing the AFD algorithm.
// Default value: 60.
// Data range:
// Constraints:
// Effect: we do not recommend the user change this parameter.
//
// Variable name: chromatix_auto_flicker_detection_data_type.afd_num_frames
// This is the number of simultaneous frames to use in the AFD.
//    The frame information is saved and once this number is available the algorithm starts.
// Default value: 6.
// Data range:
// Constraints:
// Effect: we do not recommend the user change this parameter.
//
// Varialbe name: chromatix_auto_flicker_detection_data_type.afd_frame_skip
// Reflect frame skip pattern when collecting AFD STATs.
// Default value: 1.
// Data range: 0 to 4. 0 means to collect/analyze STAT for every frame. 1 means
//   to collect/analyze STATs every other frame.
// Constraints:
// Effect: we do not recommend user to change this parameter.
//
// Varialbe name: chromatix_auto_flicker_detection_data_type.afd_num_rows
// Image height when AFD STATS is collected.
// Default value: VF image height
// Data range: 240 to VF image height
// Constraints:
// Effect: This value has to reflect the VF height.
//
// Variable name: chromatix_auto_flicker_detection_data_type.afd_num_frames_settle
// Number of frames to wait after switching exposure tables.
// Default value: 3.
// Eata range: 2 to 6.
// Constraints:
// Effect: larger value will take longer time to complete AFD but allow plenty time for
//    exposure table change to settle.
/******************************************************************************/

/* Auto Flicker Detection */
{
   `xu4`, /* Continuous Enable */
   `xf4`, /* Standard Threshold */
   `xu1+3`, /* Percent Threshold */
   `xu4`, /* Difference Threshold */
   `xu4`, /* Frame CT Threshold */
   `xu1`, /* Number of Frames */
   `xu1+2`, /* Frame Skip */
   `xu4`, /* Number of Rows */
   `xu1`, /* Numer of Frames Settle */

/******************************************************************************/
// Feature name : AFD parameters
// applicable chipset:  7k and 8k
// 3A version: N/A
// applicable operation mode: preview
//
// variable name: AFD_num_peaks_threshold
// Minimum number of peaks are need for AFD algorithm to continue
// default Value: 6
// Data Range: 3 to 8
// constraints: none
// effect: higher value imposes higher requirement for flicker detection
//
// variable name: AFD_INTL_adj_factor
// Determine how big a factor that INTL has to be away from band gap
//	when creating exp table for AFD
// default Value: 0.25
// Data Range: 0 to 0.45
// constraints: none
// effect: higher value is easier for flicker to be detected
/******************************************************************************/

   `xu1+2`, /* Num Peaks Threshold */
   `xf4`, /* INTL Adjust Factor */
},
/* Auto Scene Detection */
{
   `xu4`, /* Software Type */
   /* Scene Change Detection */
   {

/******************************************************************************/
// Feature name : 3A Scene Change Detection
// applicable chipset(s): for all chipsets
// 3a Version: 2.0
// applicable operation mode: camcorder
//
// variable name: scd_3a_enable
// The flag to enable or disable 3a scene change detection
// default value: 1
// data range: 0(feature off) and 1 (feature on)
// constraints: N/A
// effect: Enable 3A scene change detection feature
//
// variable name: scd_aec_para_mean
// This parameter controls the contribution to the dynamic threshold
//  from the mean value of the latest scd_aec_dy_window frames SADs
//  (sum of the absolute difference).
// default value: 2
// data range: 1.0 to 4.0
// constraints: N/A
// effect: Increasing this value results in an increase in the dynamic
//  threshold and therefore less scene changes will be detected.
//
// variable name: scd_aec_para_std
// This parameter control the contribution to the dynamic threshold from
//  the standard deviation of the latest scd_aec_dy_window frames SADs
//  (sum of the absolute difference)
// default value: 2.76
// data range: 1 to 10
// constraints: N/A
// effect: Increasing this value results in an increase in the dynamic
//  threshold and therefore less scene changes will be detected.
//
// variable name: scd_aec_dy_window
// This value is used to control the window size (how many frames) for
//  computing the mean and the standard deviation.
// default value: 15
// data range: [1, maximum frame rate that can be achieved]
// constraints: N/A
// effect: The smaller the window size, the higher possibility to result
//  in faulse alarms in scene change detection. The longer the window size,
//  the more possibility to result in missed scene change detections.
//
// variable name: scd_threshold_aec_lux
// This parameter is a predefined threshold in AEC scene change detection
//  lux index method.
// default value: 10
// data range: [10,100]
// constraints: N/A
// effect: Increasing this parameter will increase the threshold for lux
//  method, which results in higher requirement on the lux index changes
//  to be classified as a scene change. In another words, the higher the
//  scd_threshold_aec_lux, the less scene changes caused by brightness
//  level change will be detected.
//
// variable name: scd_af_range_threshold
// Used to control the threshold of scene change detection in auto focus
// default value: 0.5
// data range: [0,1]
// constraints: N/A
// effect: Increasing this parameter will increase threshold for scene
//  change detection caused by auto focus, therefore less scene changes
//  will be detected.
/******************************************************************************/

      `xu4`, /* Enable */
      `xf4`, /* AEC Para Mean */
      `xf4`, /* AEC Para Std */
      `xu2`, /* DY Window */
      `xu2`, /* AEC Lux Threshold */
      `xf4`, /* AF Range Threshold */
   },
   /* Snow Scene Detection */
   {

/******************************************************************************/
// Feature name: Snow/cloudy Scene Detection.
// Applicable chipset:  8k, 7x30 and newer.
// 3A version: 2.0
//
// Variable name: snow_scene_detection_enable.
// 1 (TRUE) enables the feature from AEC perspective, 0 (FALSE)
//  disables the feature.
// Applicable operation mode: Viewfinder and snapshot.
// Default value: 1.
// Data range: 0 or 1.
// Constraints: None.
// Effect: When enabled snow scene detection and compensation feature is
//         enabled.
//
// Variable name: y_cloudy_snow_threshold.
// AEC Stat regions luma values above this threshold may be
//  used as potential snow samples.
// Applicable operation mode: Viewfinder.
// default Value (calculated): Default Luma Target
// Data range: 0 or 255.
// Constraints: Should be same as or above luma target.
// Effect: Higher values detect less snow samples, lower values cause more
//         near white regions to be detected as snow samples.
//
// Variable name: awb_y_max_in_grey.
// Any AE region above this threshold is considered potential
//  snow/cloudy region.  These regions will not have WB data
//  because WB considered too bright and above YMAX WB
//  configuration.
// Applicable operation mode: Viewfinder.
// Default value (calculated) : Normal Light AWB YMax
// Data Range: 0 to 255.
// Constraints: >= AWB bounding box YMax value.
// Effect: Higher values detect less snow samples, lower values cause more
//         close to saturated regions to be detected as snow samples.
//
// Variable name: min_snow_cloudy_sample_th.
// If count of snow/cloudy regions detected above this
//  threshold, we consider the scene as snow/cloudy. Snow scene
//  severity is 0 when snow samples are less than this threshold.
// Applicable operation mode: Viewfinder.
// Default value: 10
// Data range: 0 to 64.
// Constraints: None.
// Effect: Higher values make it harder to flag current scene as snow scene.
//
// Variable name: extreme_snow_cloudy_sample_th.
// If count of detected snow regions above this threshold,
//  scene is considered extreme snow/cloudy scene.  Snow scene
//  severity is 255 when snow samples is equal or larger than this
//  threshold.
//  Full extreme_luma_target_offset is applied.
// Applicable operation mode: Viewfinder and snapshot.
// Default value: 55.
// Data range: min_snow_cloudy_sample_th to 64.
// Constraints: None.
// Effect: Higher values make it harder to flag current scene as extreme snow
//         scene or severity set to 255.
//
// Variable name: extreme_luma_target_offset.
// Maximum luma offset that can be applied when snow scene is
//  detected.  This happens when extreme_snow_cloudy_sample_th is
//  reached or exceeded and exposure index is less than outdoor
//  index.
//  Luma offset is gradually reduced for darker scenes until
//  eventually made 0 for indoor cases, this is based on exp_index.
//  (Cannot use lux_idx due to rapid change based on frame luma;
//  will cause luma offset to be unstable.)
// Applicable operation mode: Viewfinder and snapshot.
// default Value (calculated): Default Luma Target
// Data range: 0 to twice luma target.
// Constraints: None.
// Effect: Higher values make image brighter for snow scene detected.
//
// Variable name: severe_snow_scene_cap.
// Point at which backlit_max_digital_gain will be applied, value
//  is 0 to 255 for severity.  255 means snow scene detection must report 255 severity
//  for backlit_max_digital_gain to be applied.  If set to 0, it is always applied.
//  Care is needed to not use 0 otherwise backlit_max_digital_gain will always be applied.
// Spplicable operation mode: Viewfinder and snapshot.
// Default value: 255
// Data range: 0 to 255
// Constraints: None.
// Effect: See description above.
//
// Variable name: snowscene_aggressiveness
// Adjust reaction time of snow/cloudy scene compensation.
// Default value: 0.2
// Data range: 0 to 1.0
// Constraints:
// Effect: Larger makes snow/cloudy compensation react faster by updating luma
//         target.  If set too aggressive, AE oscillation may happen.
//
// Variable name: ui_snow_cloudy_display_th.
// When detection severity is larger than this threshold, UI may display icon
//     representing this type of scene.
// Applicable operation Mode: Preview, camcorder.
// Default value: 80.
// Data range: 1 to 255.
// Constraints: Larger vlaue requires scene severity to be larger to display
//              icon.
// Effect: ICON display on UI when option is enabled in UI.
/******************************************************************************/

      `xu4`, /* Enable */
      `xu4`, /* Y Snow Threshold */
      `xu4`, /* AWB Y Max in Grey */
      `xu4`, /* Min Snow Sample Threshold */
      `xu4`, /* Extreme Snow Sample Threshold */
      `xf4`, /* Extreme Luma Target Offset */
      `xu4`, /* Severe Snow Cap */
      `xf4`, /* Aggressiveness */
      `xu1+3`, /* UI Display Th */
   },
   /* Backlit Scene Detection */
   {

/******************************************************************************/
// Feature name: Backlit Scene Detection.
// Applicable chipset:  8k, 7x30 and newer.
// 3A version: 2.0
//
// Variable name: backlight_detection_enable.
// 1 (TRUE) enables the feature, 0 (FALSE) disables the feature.
// Applicable operation mode: Viewfinder and snapshot.
// Default value: 1.
// Data range: 0 or 1.
// Constraints: None.
// Effect: 1 enables the feature.
//
// Variable name: low_luma_threshold.
// Preview frame histogram samples which luma is below this
//  threshold are added to low luma count.
// Applicable operation mode: Viewfinder.
// Default value: 10.
// Data range: 0 to high_luma_threshold.
// Constraints: None.
// Effect: Lower values detect less samples as "dark" to be considered for
//         backlit detection.
//
// Variable name: high_luma_threshold.
// Histogram samples which luma is above this threshold are
//  added to high luma count.
// Applicable operation mode: Viewfinder.
// Default value: 235.
// Data range: low_luma_threshold to 255.
// Constraints: None.
// Effect: Higher values detect less samples as "bright" to be considered for
//         backlit detection.
//
// Variable name: low_luma_count_percent_threshold.
// If count of low luma samples exceed this percentage of total
//  samples, we consider potential backlight case.
// Applicable operation mode: Viewfinder.
// Default value: 10.
// Data range: 0 to 100.
// Constraints: None.
// Effect: Higher value requires more dark samples for histogram portion of
// backlight detection to flag as potential backlit scene so it reduces probability
// to detect backlight condition.
//
// Variable name: high_luma_count_percent_threshold.
// If count of high luma samples exceed this percentage of total
//  samples, we consider potential backlight case.
// Applicable operation mode: Viewfinder.
// Default value: 10.
// Data range: 0 to 100.
// Constraints: None.
// Effect: Higher value requires more bright samples for histogram portion of
// backlight detection to flag as potential backlit scene so it reduces probability
// to detect backlight condition.
//
// Variable name: backlight_la_8k_config.
// Luma Adaptation configuration when backlight scene is
//  detected, compensation portion.
// Applicable operation mode: Viewfinder.
// Default value: Same as normal light.
// Data range: N/A.
// constraints: None.
//
// Variable name: backlight_max_la_luma_target_adj.
// Maximum luma target adjustment when backlight is detected.
//  We expect to increase luma target.
// Applicable operation mode: Viewfinder.
// Default value: 1.1
// Data range: 0.5 to 2.
// Constraints: None
// Effect: >1 value will increase luma target and bring out the dark areas. <1 value
// will decrease luma target and avoid saturation in highlight areas.
//
// Variable name: max_percent_threshold.
// End of interpolation range for severity.
//   Closer value to min_percent_threshold will cause backlit compensation to
//   have more effect.
// Applicable operation mode:  Camera mode only.
// Default value:  1.
// Data range: 0.5 to 1.0
// Constraints: Due to nature of compensation affecting the detection, a smaller
//   value may cause the backlit detection to become unstable.
// Effect: More aggresive application of backlit compensation for smaller
//   max_percent_threshold values.
//
// Variable name: ui_backlit_display_th.
// When detection severity is larger than this threshold, UI may display icon
//     representing this type of scene.
// Applicable operation mode: Preview, camcorder.
// Default value: 80.
// Data range: 1 to 255.
// Constraints: Larger value requires scene severity to be larger to display
//              icon
// Effect: ICON display on UI when option is enabled in UI.
/******************************************************************************/

      `xu4`, /* Enable */
      `xu4`, /* Low Luma Threshold */
      `xu4`, /* High Luma Threshold */
      `xf4`, /* Low Luma Count Percent Threshold */
      `xf4`, /* High Luma Count Percent Threshold */
      /* Outdoor Luma Adaptation */
      {
         `xu1`, /* Shadow Range */
         `xu1`, /* Shadow Boost Allowance */
         `xu1`, /* Reduction Fine Tune */
         `xu1`, /* Highlight Supress Fine Tune */
         `xu1+3`, /* Shadow Boost Fine Tune */
      },
      `xu4`, /* Max Luma Target Adjust */
      `xf4`, /* Aggressiveness */
      `xf4`, /* Max Percent Threshold */
      `xu1+3`, /* UI Display Th */
   },
   /* Landscape Scene Detection */
   {

/******************************************************************************/
// Feature name: Landscape Scene Detection and Compensation.
// Applicable chipset(s): VFE 3.2 and later with bayer grid stats support.
// 3A version: 4.0
// Applicable operation mode:  Preview, camcorder modes and ZSL.
//
// Variable name: asd_ext_blue_th.
// Extreme blue region detection threshold If region from Bayer Grid stats is
//    above this threshold, region is considered extreme blue.
// Default value:  1.15
// Data range: 1.0 to 3.0
// Constraints: None.
// Effect: Higher value allows less extreme blue regions to be detected.
//
// Variable name: asd_ext_green_th_r.
// Extreme green region detection threshold. If region from Bayer Grid stats is
//    below this threshold and below asd_ext_green_th_b, region is considered extreme green.
// Default value:  1.1
// Data range: 0.5 to 3.0
// Constraints: Region has been white balanced.
// Effect: Higher value allows more extreme green regions to be detected.
//
// Variable name: asd_ext_green_th_b.
// Extreme green region detection threshold. If region from Bayer Grid stats is
//    below this threshold and below asd_ext_green_th_r, region is considered extreme green.
// Default value:  1.2
// Data range: 0.5 to 3.0
// Constraints: Region has been white balanced.
// Effect: Higher value allows more extreme green regions to be detected.
/****************************************************************************/

      `xu4`, /* Enable */
      `xf4`, /* Red Boost Factor */
      `xf4`, /* Green Boost Factor */
      `xf4`, /* Blue Boost Factor */
      `xf4`, /* Min Blue Green Content Detection Threshold */
      `xf4`, /* Max Blue Green Content Detection Threshold */
      `xu4`, /* Green Offset RG */
      `xu4`, /* Green Offset BG */
      `xf4`, /* Extreme Blue Threshold */
      `xf4`, /* Extreme Green Threshold R */
      `xf4`, /* Extreme Green Threshold B */
      `xf4`, /* Aggressiveness */
      `xu4`, /* Lux Idx Indoor */
      `xu4`, /* Lux Idx Outdoor */
      `xu1+3`, /* UI Display Th */
   },
   /* Portrait Scene Detection */
   {

/******************************************************************************/
// Feature name: Portrait Scene Detection.
// Applicable chipset(s): VFE 3.1 and later with Bayer support.
//
// Variable name: portrait_detection_enable.
// Enables and disables the feature.
// Applicable operation mode:  Preview, camcorder record and snapshot.
// Default value:  1.
// Data range: 0 to 1.
// Constraints: None.
// Effect: 0 disables the feature; 1 enables the feature.
//
// Variable name: skin_color_boost_factor.
// Allows skin tones to be modified to look paler or tanner.
// Applicable operation mode:  Preview, camcorder record and snapshot.
// Default value:  0.
// Data range: -1 to +1.
// Constraints: -1 to +1 in 1/100 step.
// Effect: +1 = most pale, -1 = most tan.
//
// Variable name: min_face_content_threshold.
// Determines amount of area with respect to frame size to be called a
//     portrait scene.
// Applicable operation mode:  Preview, camcorder record and snapshot.
// Default value:  0.010
// Data range: 0 to 1.
// Constraints: None.
// Effect: 0 will always detect as portrait as long as a face has been detected.
//   1 will require face area to cover the whole frame to be called a portait
//   scene.  Default value needs 1% of the frame area to be face to be called
//   portrait, although severity will be close to 0.
//
// Variable name: max_face_content_threshold.
// Determines amount of area with respect to frame size to be called a
//     portrait scene.
// Applicable operation mode:  Preview, camcorder record and snapshot.
// Default value:  0.05
// Data range: 0 to 1.
// Constraints: None.
// Effect: If face area w.r.t. to frame size is larger than this threshold,
//   portrait severity will be 255.  Portrait severity is interpolated based
//   on face area between min and max_face_content_threshold.
//
// Variable name: soft_focus_degree.
// Amount of blurring to be applied
//  on image when portrait scene is detected.  This gets interpolated
//  according to portrait severity value.
// Applicable operation mode:  Preview, camcorder record and snapshot.
// Default value:  0.9
// Data range: 0.5 to 1.
// Constraints: None.
// Effect: Smaller value will result in softer focus appearance.
//
// Variable name: aggressiveness.
// Adjust reaction time of portrait compensation.
// Applicable operation mode:  Preview, camcorder.
// Default value: 0.5
// Data range: 0 to 1.0
// Constraints: None.
// Effect: Larger value makes portrait compensation react faster.
//
// Variable name: ui_portrait_display_th.
// When detection severity is larger than this threshold, UI may display icon
//     representing this type of scene.
// Applicable operation mode:  Preview, camcorder.
// Default value: 80.
// Data range: 1 to 255.
// Constraints: Larger value requires scene severity to be larger to display
//              icon.
// Effect: ICON display on UI when option is enabled in UI.
/******************************************************************************/

      `xu4`, /* Enable */
      `xf4`, /* Skin Color Boost Factor */
      `xf4`, /* Min Face Content Threshold */
      `xf4`, /* Max Face Content Threshold */
      `xf4`, /* 7x7 Soft Focus Degree */
      `xf4`, /* Soft Focus Degree */
      `xf4`, /* Aggressiveness */
      `xu1+3`, /* UI Display Th */
   },
   /* Sunset Color Conversion */
   /* Noise Weight: 0.000000 */
   /* Saturation: Red - 1.000000, Green - 1.000000, Blue - 1.000000 */
   {
      {
         /* a_m, a_p */
         `xf4`, `xf4`,
         /* b_m, b_p */
         `xf4`, `xf4`,
         /* c_m, c_p */
         `xf4`, `xf4`,
         /* d_m, d_p */
         `xf4`, `xf4`,
         /* k_cb, k_cr */
         `xu2`, `xu2`
      },
      {
         /* v0, v1, v2 */
         `xf4`, `xf4`, `xf4`,
         /* k */
         `xu2+2`
      }
   },
   /* TL84 Skintone Color Conversion */
   /* Noise Weight: 0.000000 */
   /* Saturation: Red - 1.000000, Green - 1.000000, Blue - 1.000000 */
   {
      {
         /* a_m, a_p */
         `xf4`, `xf4`,
         /* b_m, b_p */
         `xf4`, `xf4`,
         /* c_m, c_p */
         `xf4`, `xf4`,
         /* d_m, d_p */
         `xf4`, `xf4`,
         /* k_cb, k_cr */
         `xu2`, `xu2`
      },
      {
         /* v0, v1, v2 */
         `xf4`, `xf4`, `xf4`,
         /* k */
         `xu2+2`
      }
   },
   /* D65 Skintone Color Conversion */
   /* Noise Weight: 0.000000 */
   /* Saturation: Red - 1.000000, Green - 1.000000, Blue - 1.000000 */
   {
      {
         /* a_m, a_p */
         `xf4`, `xf4`,
         /* b_m, b_p */
         `xf4`, `xf4`,
         /* c_m, c_p */
         `xf4`, `xf4`,
         /* d_m, d_p */
         `xf4`, `xf4`,
         /* k_cb, k_cr */
         `xu2`, `xu2`
      },
      {
         /* v0, v1, v2 */
         `xf4`, `xf4`, `xf4`,
         /* k */
         `xu2+2`
      }
   },
   /* A Skintone Color Conversion */
   /* Noise Weight: 0.000000 */
   /* Saturation: Red - 1.000000, Green - 1.000000, Blue - 1.000000 */
   {
      {
         /* a_m, a_p */
         `xf4`, `xf4`,
         /* b_m, b_p */
         `xf4`, `xf4`,
         /* c_m, c_p */
         `xf4`, `xf4`,
         /* d_m, d_p */
         `xf4`, `xf4`,
         /* k_cb, k_cr */
         `xu2`, `xu2`
      },
      {
         /* v0, v1, v2 */
         `xf4`, `xf4`, `xf4`,
         /* k */
         `xu2+2`
      }
   },
},
/* Zero Shutter Lag */
{

/******************************************************************************/
// Feature name: Zero shutter lag.
//
// Variable name: default_shutter_lag.
// Default shutter lag value used in Zero Shutter Lag mode in ms.
// Default value: 300.
// Data range: bigger than or equal to 0.
// Constraints: None.
// Effect: The bigger the value is, the more images buffered in ZSL mode.
//
// Variable name: max_Q_factor_reduction.
// The maximum image Q factor percentage reduction used in image buffer size
//   control. The min image Q factor =
//   default Q factor * (1-max_Q_factor_reduction).
// Default value: 20.
// Data range: 0 to 30.
// Constraints: None.
// Effect: The bigger the value is, the lower the potential image quality when
//         buffer length control is enabled.
/******************************************************************************/

   `xu2`, /* Default Shutter Lag */
   `xu2`, /* Max Q Factor Reduction */
},
/* Post Processing */
{
   /* HDR */
   {

/******************************************************************************/
// Feature name: HDR.
// Applicable chipset(s): ALL with HDR feature.
// Applicable operation mode:  HDR feature turned on.
//
// Variable name: global_motion_tolerance.
// The maximum amount of global motion which can be tolerated
//       before HDR is turned off.
// Default value:  0.05
// Data range: 0 to 0.05
// Constraints: None.
// Effect: Decreasing the tolerance allows less global motion in the image
//         before HDR is turned off.
//
// Variable name: contrast_meter.
// The overall contrast of the HDR image.
// Default value:  0.25
// Data range: 0 to 1.0
// Constraints: None.
// Effect: Increasing contrast gives more contrast to the final HDR image.
//
// Variable name: normal_lowlight_boost_meter.
// Adjustment of the length of the tail of the histogram control curve under normal light.
// Default value:  0.5
// Data range: 0 to 1.0
// Donstraints: Highly recommended not to modify it.
// Effect: Increasing the parameter will boost up more in the low light area.
//
// Variable name: bright_lowlight_boost_meter.
// Adjustment of the length of the tail of the histogram control curve under bright light.
// Default value:  0.5
// Data range: 0 to 1.0
// Constraints: Highly recommended not to modify it.
// Effect: Increasing the parameter will boost up more in the low light area.
/********************************************************************************/

      `xf4`, /* Tolerance */
      `xf4`, /* Contrast Meter */
      `xf4`, /* Normal/Lowlight Boost Meter */
      `xf4`, /* Bright light Boost Meter */
   },
   /* Face Detection */
   {

/******************************************************************************/
// Feature name : Face Detection/Recognition.
// Applicable chipset:  7k and newer supporting face detection.
// Applicable operation mode: Viewfinder.
//
// Variable name: minimum_face_width.
// Minimum number of pixels for a side for the face to be detected; cannot go lower than 20
// Default: 20.
// Data Range: 20-8192
// Effect: It affects performance; the lower the minimum is, the longer it takes
//
// Variable name: maximum_face_width.
// Maximum number of pixels for a side for the face to be detected;
// Default: 0.
// Data Range: 0, 20-8192 (bigger than minimum_face_width).
// Effect: It affects performance; the higher the maximum is, the longer it takes.
//   If 0, it indicates it will be set to the shorter edge of the input frame.
//
// Variable name: maximum_num_face_to_detect.
// Maximum number of faces to detect (up to 1023)
// Default: 8.
// Effect: It affects performance; the higher the maximum is, the longer it takes to detect.
//
// For the following three variables, please read section below first:
//
// Face image direction and angle range (Non-tracking related settings)
// Lower  12 bits are for right side of Diagonal and Sideway faces
// Higher 12 bits are for left  side of Diagonal and Sideway faces
// The angles below are according the following diagram:
//
//                                                /^\
//                                               / | \
//                                                 |
//                           0                  _______
//                     315   |   45            /       \
//                        \     /             / .    .  \
//                  270 -         - 90       (     |     )
//                        /     \             \  \___/  /
//                     225   |    135          \       /
//                          180                 \_____/
//
//
// ANGLE_0  = 0x00001001  /* Top of the head facing from 345 degrees to 15  degrees */
// ANGLE_1  = 0x00002002  /* Top of the head facing from 15  degrees to 45  degrees */
// ANGLE_2  = 0x00004004  /* Top of the head facing from 45  degrees to 75  degrees */
// ANGLE_3  = 0x00008008  /* Top of the head facing from 75  degrees to 105 degrees */
// ANGLE_4  = 0x00010010  /* Top of the head facing from 105 degrees to 135 degrees */
// ANGLE_5  = 0x00020020  /* Top of the head facing from 135 degrees to 165 degrees */
// ANGLE_6  = 0x00040040  /* Top of the head facing from 165 degrees to 195 degrees */
// ANGLE_7  = 0x00080080  /* Top of the head facing from 195 degrees to 225 degrees */
// ANGLE_8  = 0x00100100  /* Top of the head facing from 225 degrees to 255 degrees */
// ANGLE_9  = 0x00200200  /* Top of the head facing from 255 degrees to 285 degrees */
// ANGLE_10 = 0x00400400  /* Top of the head facing from 285 degrees to 315 degrees */
// ANGLE_11 = 0x00800800  /* Top of the head facing from 315 degrees to 345 degrees */
//
// Variable name: angles_to_detect_pose_front.
// Detectable angles for front pose faces (bitwise OR the angles together e.g. ANGLE_0 | ANGLE_1 | ANGLE_2).
// Default: ANGLE_8 | ANGLE_9 | ANGLE_10 | ANGLE_11 | ANGLE_0 | ANGLE_1 | ANGLE_2 | ANGLE_3 | ANGLE_4
//   This default takes care of the phone rotating either left of right (depends on the way modules are mounted also).
// Effect: It affects performance; the more angles, the longer it takes.
//
// Variable name: angles_to_detect_pose_half_profile.
// Detectable angles for half profile faces (faces not looking directly toward the phone, but 45 degress to the side).
// Default: ANGLE_8 | ANGLE_9 | ANGLE_10 | ANGLE_11 | ANGLE_0 | ANGLE_1 | ANGLE_2 | ANGLE_3 | ANGLE_4
//   This default takes care of the phone rotating either left of right (depends on the way modules are mounted also).
// Effect: It affects performance; the more angles, the longer it takes.
//
// Variable name: angles_to_detect_pose_profile.
// Detectable angles for sideways faces.
// Default: ANGLE_NONE.
// Effect: It affects performance; the more angles, the longer it takes.
//
// Below are face recognition tuning parameters
//
// Variable name: max_num_users.
// Maximum number of users in the database.
// Default: 10
// Data Range: anything greater than or equal to 1.
//
// Variable name: max_data_per_user.
// Maximum number of data per user in the database.
// Default: 5.
// Data Range: 1-10.
/******************************************************************************/

      `xu4`, /* Minimum Face Width */
      `xu4`, /* Maximum Face Width */
      `xu4`, /* Maximum Num Faces to Detect */
      `xu4`, /* Angles to Detect Front */
      `xu4`, /* Angles to Detect Half-Profile */
      `xu4`, /* Angles to Detect Profile */
   },
   /* Face Recognition */
   {
      `xu4`, /* Max Number of Users */
      `xu4`, /* Max Data per User */
   },
   /* Chroma Aliasing */
   {
      `xu1+3`, /* Control Method - 1 = Gain, 0 = Lux Index */
      /* Trigger Points */
      {
         `xf4`, /* Gain Start */
         `xf4`, /* Gain End */
         `xu4`, /* Lux Index Start */
         `xu4`, /* Lux Index End */
      },

/******************************************************************************/
// Feature name: Chroma aliasing correction.
// Applicable chipset(s): ALL with chroma aliasing correction.
// Applicable operation mode:  Chroma aliasing correction feature turned on
//
// Variable name: correction_strength.
// Control the overall strength of chroma suprresion effect.
// Default value:  0.
// Data range: 0 or 1.
// Constraints: Boolean type (o or 1).
// Effect: Default setting 0 works for most cases, when much stronger chroma aliasing correction is needed,
//         the parameter is set to 1.
//
// Variable name: brightness_threshold.
// Chroma aliasing correction is applied on the areas that are brighter than the threshold.
// Default value:  10.
// Data range: 0 to 255.
// Constraints: None.
// Effect: Increasing the threshold will have less areas been influenced by chroma aliasing correction.
//
// Variable name: soft_threshold_center.
// There is a soft thresholding control in chroma aliasing correction, which controls the sensitivity of
//       the correction. This parameter is the soft thresholding center.
// Default value:  45.
// Data range: 0 to 255.
// Constraints: None.
// Effect: Increasing the threshold center will make chroma aliasing correction to be less sensitive,
//       so it will have less correction.
//
// Variable name: soft_threshold_span.
// There is a soft thresholding control in chroma aliasing correction, which controls the sensitivity of
//       the correction. This parameter is the soft thresholding span range.
// Default value:  10.
// Data range: 0 to 63.
// Constraints: None.
// Effect: This parameter controls the transfer range of the soft thresholding, the larger the number,
//       the larger the transfer range.
/********************************************************************************/

      /* Lowlight */
      {
         `xu4`, /* Correction Strength */
         `xu1`, /* Brightness Threshold */
         `xu1`, /* Threshold Center */
         `xu1+1`, /* Soft Threshold Span */
      },
      /* Normal light */
      {
         `xu4`, /* Correction Strength */
         `xu1`, /* Brightness Threshold */
         `xu1`, /* Threshold Center */
         `xu1+1`, /* Soft Threshold Span */
      },
   },
   /* Color Tint */
   {

/******************************************************************************/
// Feature name: Color tint correction.
// Applicable chipset(s): ALL with color tint correction.
// Applicable operation mode:  color tint correction feature turned on.
//
// Variable name: tint_correction_mode.
// Select the mode of color tint correction.
// Default value:  0.
// Data range: 0 or 1.
// Constraints: Boolean type (0 or 1).
// Effect: Mode 0 works for most cases, it has short latency and reasonable accuracy.
//         Mode 1 has higher correction accuracy but with longer latency.
//
// Variable name: tint_correction_strength.
// Control the strength of color tint correction.
// Default value:  22.
// Data range: 5 or 70.
// Constraints: Default value is highly recommended.
// Effect: Increasing this number will increase the color tint correction strength meaning
//    more severe color tint can be corrected, but it may desaturate some colors when its too high.
//
// Variable name: tint_correction_accuracy_degree.
// Control the accuracy degree of color tint correction.
// Default value:  8.
// Data range: 1 or 16.
// Constraints: Default value is highly recommended.
// Effect: Increasing this number will increase the color tint correction accuracy. However,
//       when the setting is too high some trailing color tint may happen for video or viewfinder mode
//       when camera or objects move.
/********************************************************************************/

      `xu4`, /* Correction Mode */
      `xu1`, /* Correction Strength */
      `xu1+2`, /* Correction Accuracy Degree */
   },
   /* Local Tone Mapping */
   {

/******************************************************************************/
// Feature name : LTM.
// Applicable chipset: MSM8094 and later.
// Applicable operation mode:  For VF and snapshot.
//
// Variable names: fCV_R, fCV_G, fCV_B, fCV_Kc, fCV_Cthr.
// RGB to Yp conversion coefficients and strong color inclusion parameters.
// Default values (for 12-bit data):
//   0.299000f, 0.587000f, 0.114000f, 0.700000f, 32.000000f
// Data range: 0 to 1.0f for fCV_R, fCV_G, fCV_B, 0 to 10.0f for fCV_Kc, and
//   0 to 127 for fCV_Cthr.
// Constraints: fCV_R, fCV_G, fCV_B should sum up to 1.0f.
// Effect: fCV_R, fCV_G, fCV_B are regular RGB->Y conversion; fCV_Cthr sets the
//   threshold of strong Cb/Cr color, and fCV_Kc sets the strength of strong
//   color inclusion to Yp.  Note that debug_out_sel in hardware register allows
//   LTM to output local tone mapped RGB output (0x0, default), brightness filter
//   output (0x1), local tone mapped Yp output (0x2), and Yp (0x3) images.
//   Choosing 0x3 allows monitoring the Yp tuning effects.
//
// Variable name: nInitCntFactor.
// Initial pixel count factor of brightness filter 3D bins.
// Default value: 1.
// Data range: 0 to 8.
// Constraints: 0 <= nInitCntFactor <= 8;
// Effect: nInitCntFactor initialized brightness filter bin pixel counts to
//   2^nInitCntFactor. Larger values would reduce the strength of brightness
//   filter and vice versa.
//
// Variable name: fSigmaXY, fSigmaZ.
// Sigma of Gaussian smoothing of brightness mask filter 3D bins in XY and Z
//    dimensions.
// Default values: 1.100000f, 2.700000f.
// Data range: 0.2f to 12.0f.
// Constraints: None.
// Effect: Higher value of fSigmaXY and fSigmaZ enhance brightness mask
//   filtering in image and brightness dimensions, respectively.  Note that
//   debug_out_sel in hardware register allows LTM to output local tone mapped
//   RGB output (0x0, default), brightness filter output (0x1), local tone mapped
//   Yp output (0x2), and Yp (0x3) images. Choosing 0x1 allows monitoring
//   brightness mask tuning effects.
//
// Variable name: nNormalLoCut, nNormalHiCut, nStrongLoCut, nStrongHiCut.
// Cutoff values of scene-dependent brightness mask rectification curve for
//    normal and strong image clutterness.
// Default values: 1, 5, 17, 17.
// Data range: 0 to 31.
// Constraints: Integer indices for 64-entry LUT of mask rectification curve.
// Effect: Rectification curve further adjusts brightness mask output to
//   approximate local image brightness. Low cuts of normal and strong image
//   clutterness control the low brightness pixels and High cuts control the
//   high brightness pixels.  Choosing debug_out_sel = 0x1 allows monitoring
//   brightness mask and rectification curve tuning effects.
//
// Variable name: fBusyThr1, fBusyThr2.
// Image busyness decision thresholds.
// Default values: 1.300000f, 3.100000f.
// Data range: > 0.
// Constraints: fBusyThr1 < fBusyThr2.
// Effect: Image busyness is 0 if heuristics #1 is less than fBusyThr1 and
//   busyness is 1 if heuristics #1 is greater than fBusyThr2, and linearly
//   increasing from 0 to 1.0 in between. Image busyness is later combined with
//   low-end image clutterness to decide the low cutoff value of mask
//   rectification curve.
//
// Variable name: nLowTrig0, nLowTrig1, nLowTrig2, nLowTrig3;
//   nHighTrig0, nHighTrig1, nHighTrig2, nHighTrig3.
// Image clutterness decision thresholds.
// Default values:
//   6000, 12000, 20000, 35000;
//   4000, 9000, 50000, 60000.
// Data range: > 0.
// Constraints: nLowTrig0 < nLowTrig1 < nLowTrig2 < nLowTrig3 and
//   nHighTrig0 < nHighTrig1 < nHighTrig2 < nHighTrig3.
// Effect: When low-end heuristics #2 goes from nLowTrig0 to nLowTrig1, low-end
//   image clutterness goes linearly from 0 to 1.0. From nLowTrig1 to nLowTrig2,
//   low-end image clutterness remains 1.0. From nLowTrig2 to nLowTrig3, low-end
//   image clutterness descend from 1.0 to 0. Similarly for high-end heuristics
//   #2.  Low-end image clutterness is combined with image busyness to determine
//   low-end cutoff value of mask rectification curve and high-end image
//   clutterness decides the high-end cutoff value of mask rectification curve.
//
// Variable name: fManualGTMGain, fManualGTMSigma, fW1_LA.
// Manual global tone mapping curve generation parameters and weighting factor of
//    automatic global tone mapping curve (LA curve).
// Default values: 2.200000f, 10.240000f, 0.500000f.
// Data range: 0 < fManualGTMGain; 0 < fManualGTMSigma < 64.0f;
//   0 <= fW1_LA <= 1.0f.
// Constraints: None.
// Effect: fManualGTMGain and fManualGTMSigma decide the magnitude and sigma of
//   Gaussian-shaped manual global tone mapping (GTM) curve. fW1_LA is the
//   weight of automatic luma adaptation (LA) global tone mapping curve.
//   (1 - fW1_LA) is the weight of manual GTM curve which modulates the LA GTM
//   curve. Increasing fManualGTMGain would make output image brighter.
//   Increasing fManualGTMSigma would make brightness boost range wider.
//
// Variable name: fScaleConstraintLB.
// Lower bound constraint for scene-dependent master/shift Gaussian-like scale
//    curve.
// Default value: 0.450000f.
// Data range: 0.0 to 1.0.
// Constraints: None.
// Effect: fScaleConstraintLB controls the lower bound of the master/shift
//   Gaussian-like scale curve.  Lower value may provide larger curve set change
//   from low brightness mask value to high mask value, but artifacts may arise
//   if not carefully tuned.
//
// Variable name: fScaleSigmaMult, fScaleWidthLB.
// Sigma multiplication factor and width lower bound of master/shift scale curve.
// Default values: 0.750000f, 10.000000f.
// Data range: fScaleSigmaMult: 0 to 20.0f; fScaleWidthLB: 1.0f to 127.0f.
// Constraints: None.
// Effect: fScaleSigmaMult multiplies to the estimated sigma for the sigma of the
//   master/shift scale curve, and fScaleWidthLB bounds the scale curve sigma
//   from below. Increasing fScaleSigmaMult makes the scene-dependent scale
//   curve wider, and increasing fScaleWidthLB makes the minimum scale curve
//   width wider.
//
// Variable name: fMasterScaleAdj.
// Magnitude adjusting factor for master scale curve.
// Default value: 0.750000f.
// Data range: 0 to 1.0f.
// Constraints: None.
// Effect: fMasterScaleAdj is multiplied to the estimated scene-dependent
//   master/shift scale curve magnitude to scale down the range from top (always
//   1.0) to bottom. If fMasterScaleAdj is 0, then the resultant master scale
//   curve will be a flat line of 1.0.
//
// Variable name: fShiftSigma, fShiftMag.
// Sigma and magnitude of sigmoid shift curve.
// Default values: 0.100000f, 0.250000f.
// Data range: > 0.
// Constraints: None.
// Effect: fShiftSigma and fShiftMag are the sigma and magnitude of the sigmoid
//   shift curve, respectively. Increasing fShiftSigma makes the sigmoid shift
//   curve wider and flatter, and increasing fShiftMag makes the magnitude of the
//   shift curve larger.
//
// Variable name: nSoftThr0, nSoftThr1, nSoftThrSlope.
// Soft threshold curve parameters to overlay sigmoid shift curve.
// Default values: 3, 18, 16.
// Data range: nSoftThr0 & nSoftThr1: 0 to 64; nSoftThrSlope (Q8): >= 0.
// Constraints: nSoftThr1 > nSoftThr0.
// Effect: Soft threshold overlay is 0 between 0 and nSoftThr0, then linearly
//   increasing to nSoftThrSlope * (nSoftThr1 - nSoftThr0) / 256 at nSoftThr1,
//   and flat afterwards.  This curve is added upon the sigmoid shift curve for
//   the final shift curve.
//
// Variable name: fShiftScaleAdj.
// Adjusting factor of the shift scale magnitude
// Default value: 1.050000f.
// Data range: >= 0.
// Constraints: None.
// Effect: fShiftScaleAdj is multiplied to the estimated scene-dependent
//   master/shift scale curve magnitude to scale up/down the range from top
//   (always 1.0) to bottom.  If fShiftScaleAdj is 0, then the resultant shift
//   scale curve will be a flat line of 1.0.
/******************************************************************************/

      `xf4`, /* CV_R */
      `xf4`, /* CV_G */
      `xf4`, /* CV_B */
      `xf4`, /* CV_Kc */
      `xf4`, /* CV_Cthr */
      `xu4`, /* InitCntFactor */
      `xf4`, /* SigmaXY */
      `xf4`, /* SigmaZ */
      `xu4`, /* NormalLoCut */
      `xu4`, /* NormalHiCut */
      `xu4`, /* StrongLoCut */
      `xu4`, /* StrongHiCut */
      `xf4`, /* BusyThr1 */
      `xf4`, /* BusyThr2 */
      `xu4`, /* LowTrig0 */
      `xu4`, /* LowTrig1 */
      `xu4`, /* LowTrig2 */
      `xu4`, /* LowTrig3 */
      `xu4`, /* HighTrig0 */
      `xu4`, /* HighTrig1 */
      `xu4`, /* HighTrig2 */
      `xu4`, /* HighTrig3 */
      `xf4`, /* ManualGTMGain */
      `xf4`, /* ManualGTMSigma */
      `xf4`, /* W1_LA */
      `xf4`, /* ScaleConstraintLB */
      `xf4`, /* ScaleSigmaMult */
      `xf4`, /* ScaleWidthLB */
      `xf4`, /* MasterScaleAdj */
      `xf4`, /* ShiftSigna */
      `xf4`, /* ShiftMag */
      `xu4`, /* SoftThr0 */
      `xu4`, /* SoftThr1 */
      `xu4`, /* SoftThrSlope */
      `xf4`, /* ShiftScaleAdj */
   },
},

/******************************************************************/
